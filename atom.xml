<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>1</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jas-wang.fun/"/>
  <updated>2020-07-20T08:47:58.425Z</updated>
  <id>http://jas-wang.fun/</id>
  
  <author>
    <name>Jas wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PHP性能分析工具——xhprof</title>
    <link href="http://jas-wang.fun/2020/07/20/php-xhprof/"/>
    <id>http://jas-wang.fun/2020/07/20/php-xhprof/</id>
    <published>2020-07-20T01:52:46.000Z</published>
    <updated>2020-07-20T08:47:58.425Z</updated>
    
    <content type="html"><![CDATA[<p>简介<br>XHProf是一个分层PHP性能分析工具。它报告函数级别的请求次数和各种指标，包括阻塞时间，CPU时间和内存使用情况。<br>Xhprof是facebook开源出来的一个php轻量级的性能分析工具，跟Xdebug类似，但性能开销更低，还可以用在生产环境中，也可以由程序开关来控制是否进行profile。</p><hr><h5 id="什么时候应该进行性能分析？"><a href="#什么时候应该进行性能分析？" class="headerlink" title="什么时候应该进行性能分析？"></a>什么时候应该进行性能分析？</h5><p>在考虑是否进行性能分析时，你首先要想：应用是否存在性能问题？如果有，你要进一步考虑：这个问题有多大？<br>如果你不这样做，将会陷入一个陷阱——过早优化，这可能会浪费你的时间。<br>为了评断应用是否存在性能问题，你应该确定性能目标。例如，100 个并发用户的响应时间小于 1s 。<br>然后，你需要进行基准测试，看是否达到这个目标。一个常见的错误是，在开发环境进行基准测试。事实上，你必须在生产环境进行基准测试。</p><h5 id="XHProf-XHGui"><a href="#XHProf-XHGui" class="headerlink" title="XHProf + XHGui"></a>XHProf + XHGui</h5><p>XHProf 由 Facebook 开发的，包含一个基本的用户界面用于查看性能数据。此外，Paul Reinheimer 开发了 XHGui 和一个增强的用户界面（UI）用于查看、比较和分析性能数据。</p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.pecl 安装</span><br><span class="line">pecl install xhprof 安装完成直接重启php </span><br><span class="line">$ php -m | grep xhprof</span><br><span class="line">xhprof</span><br><span class="line">2.源码安装</span><br><span class="line">wget http:&#x2F;&#x2F;pecl.php.net&#x2F;get&#x2F;xhprof-0.9.4.tgz</span><br><span class="line"></span><br><span class="line">tar -zxvf xhprof-0.9.4.tgz &amp;&amp; cd xhprof-0.9.4.tgz</span><br><span class="line">phpize &amp;&amp; .&#x2F;configure &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>一旦你编译了该扩展程序，您必须启用它。为此，您需要在 php.ini 文件添加以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[xhprof]</span><br><span class="line">extension         &#x3D; xhprof.so  </span><br><span class="line">xhprof.output_dir &#x3D; &#x2F;var&#x2F;www&#x2F;html&#x2F;php-run-tmp&#x2F;  定义输出文件的存放位置</span><br></pre></td></tr></table></figure><p>完成后重启php<br>具体文档可以查看官方文档地址 ：<a href="https://www.php.net/xhprof" target="_blank" rel="noopener">https://www.php.net/xhprof</a></p><p>例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$XHPROF_ROOT &#x3D; realpath(dirname(__FILE__) .&#39;&#x2F;..&#39;);</span><br><span class="line">include_once $XHPROF_ROOT . &quot;&#x2F;xhprof_lib&#x2F;utils&#x2F;xhprof_lib.php&quot;;</span><br><span class="line">include_once $XHPROF_ROOT . &quot;&#x2F;xhprof_lib&#x2F;utils&#x2F;xhprof_runs.php&quot;;</span><br><span class="line">&#x2F;&#x2F;开启xhprof</span><br><span class="line">xhprof_enable(XHPROF_FLAGS_CPU + XHPROF_FLAGS_MEMORY);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注册一个函数，当程序执行结束的时候去执行它。</span><br><span class="line">register_shutdown_function(function() &#123;</span><br><span class="line">    &#x2F;&#x2F;stop profiler</span><br><span class="line">    $xhprof_data &#x3D; xhprof_disable();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;冲刷(flush)所有响应的数据给客户端</span><br><span class="line">    if (function_exists(&#39;fastcgi_finish_request&#39;)) &#123;</span><br><span class="line">        fastcgi_finish_request();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    $xhprof_runs &#x3D; new XHProfRuns_Default();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;save the run under a namespace &quot;xhprof_foo&quot;</span><br><span class="line">    $run_id &#x3D; $xhprof_runs-&gt;save_run($xhprof_data, &quot;xhprof_foo&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://images2018.cnblogs.com/blog/663847/201805/663847-20180513110700253-1848170476.png" alt=""></p><h5 id="默认的UI里列出了："><a href="#默认的UI里列出了：" class="headerlink" title="默认的UI里列出了："></a>默认的UI里列出了：</h5><ul><li>funciton name ： 函数名</li><li>calls: 调用次数</li><li>Incl. Wall Time (microsec)： 函数运行时间（包括子函数）</li><li>IWall%：函数运行时间（包括子函数）占比</li><li>Excl. Wall Time(microsec)：函数运行时间（不包括子函数）</li><li>EWall%：函数运行时间（不包括子函数）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简介&lt;br&gt;XHProf是一个分层PHP性能分析工具。它报告函数级别的请求次数和各种指标，包括阻塞时间，CPU时间和内存使用情况。&lt;br&gt;Xhprof是facebook开源出来的一个php轻量级的性能分析工具，跟Xdebug类似，但性能开销更低，还可以用在生产环境中，也可以
      
    
    </summary>
    
    
      <category term="PHP" scheme="http://jas-wang.fun/categories/PHP/"/>
    
    
      <category term="php" scheme="http://jas-wang.fun/tags/php/"/>
    
      <category term="性能分析工具" scheme="http://jas-wang.fun/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>常见问题以及解决办法【todo】</title>
    <link href="http://jas-wang.fun/2020/07/17/question/"/>
    <id>http://jas-wang.fun/2020/07/17/question/</id>
    <published>2020-07-17T01:52:46.000Z</published>
    <updated>2020-07-20T09:14:10.472Z</updated>
    
    <content type="html"><![CDATA[<p>摘要<br>这里收集了PHP中经常遇到的问题和解决的办法</p><hr><h5 id="高并发下如何防止修改同一条数据"><a href="#高并发下如何防止修改同一条数据" class="headerlink" title="高并发下如何防止修改同一条数据"></a>高并发下如何防止修改同一条数据</h5><p>解决办法：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要&lt;br&gt;这里收集了PHP中经常遇到的问题和解决的办法&lt;/p&gt;
&lt;hr&gt;
&lt;h5 id=&quot;高并发下如何防止修改同一条数据&quot;&gt;&lt;a href=&quot;#高并发下如何防止修改同一条数据&quot; class=&quot;headerlink&quot; title=&quot;高并发下如何防止修改同一条数据&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="PHP" scheme="http://jas-wang.fun/categories/PHP/"/>
    
    
      <category term="php" scheme="http://jas-wang.fun/tags/php/"/>
    
      <category term="mysql" scheme="http://jas-wang.fun/tags/mysql/"/>
    
      <category term="高并发" scheme="http://jas-wang.fun/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>MySQL性能优化</title>
    <link href="http://jas-wang.fun/2020/07/16/mysql/"/>
    <id>http://jas-wang.fun/2020/07/16/mysql/</id>
    <published>2020-07-16T10:52:46.000Z</published>
    <updated>2020-07-20T00:41:48.668Z</updated>
    
    <content type="html"><![CDATA[<p>摘要 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要 &lt;/p&gt;

      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://jas-wang.fun/categories/MySQL/"/>
    
    
      <category term="MySQL性能优化" scheme="http://jas-wang.fun/tags/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>PHP技术学习路线</title>
    <link href="http://jas-wang.fun/2020/07/15/route/"/>
    <id>http://jas-wang.fun/2020/07/15/route/</id>
    <published>2020-07-15T01:52:46.000Z</published>
    <updated>2020-07-20T02:16:31.447Z</updated>
    
    <content type="html"><![CDATA[<h3 id="入门阶段"><a href="#入门阶段" class="headerlink" title="入门阶段"></a>入门阶段</h3><h4 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h4><ul><li><p>掌握基本HTML、JS、CSS语法；熟悉 Bootstrap。<br>验收最低标准：模仿写出jd.com或者vip.com首页第一屏内容。</p></li><li><p>熟悉Linux命令行<br>熟悉常用发行版系统(CentOS、Ubuntu)安装<br>熟悉常用命令行操作，包括文件管理、用户管理、权限管理、防火墙管理等<br>熟悉VIM使用</p></li></ul><p>验收最低标准：掌握lnmp环境搭建。</p><h4 id="PHP基础"><a href="#PHP基础" class="headerlink" title="PHP基础"></a>PHP基础</h4><ul><li>掌握PHP基础语法、文件上传、cookie、Session、JSON。</li><li>掌握MySQL数据库连接：pdo使用。</li><li>掌握redis连接及简单应用。</li><li>掌握命名空间。</li><li>掌握面向对象编程思想。</li></ul><p>参考：<br><a href="https://www.runoob.com/php/php-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/php/php-tutorial.html</a></p><h4 id="学习框架"><a href="#学习框架" class="headerlink" title="学习框架"></a>学习框架</h4><ul><li><p>学会使用ThinkPHP框架。主要是该框架在国内使用普及率太高了。不建议使用Laravel入门，因为该框架使用了较多的语法糖、第三方库，对新手可能有难度。</p></li><li><p>验收最低标准：可以使用ThinkPHP最新版作为入手框架，写出一个简单的博客。页面简单写就行。数据之间使用TP的 display 渲染到页面。</p></li></ul><h4 id="学习写接口"><a href="#学习写接口" class="headerlink" title="学习写接口"></a>学习写接口</h4><ul><li>学会 Charles 抓包，看豆瓣的接口返回的数据。</li><li>学会写接口（GET、POST）的就行。</li><li>学会使用 POSTMAN。</li></ul><p>验收标最低准：把上面的博客项目改成前后端分离的，先写完接口（最好有文档），再在页面里使用ajax调用接口数据。</p><p>至此，你已经入门了。如果需要继续往下，还要学习。</p><h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><h4 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h4><ul><li>使用 composer 安装PHP第三方库</li><li>对于PHP断点调试非常熟悉</li><li>学习常用PHP扩展</li><li>使用 SPL</li><li>掌握 PSR 规范</li><li>掌握反射的使用</li><li>掌握设计模式</li><li>熟练使用常用框架。</li><li>了解php和php-fpm的大部分配置选项和含义。</li><li>熟悉HTTP协议。</li><li>熟悉正则表达式。</li></ul><h4 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h4><ul><li>熟悉MYSQL优化的一些技巧，例如MySQL的性能追查，包括slow_log/explain等；对于order by、limit、like等一些坑能避开；能够熟练使用常用的索引；对于表结构创建选用哪种数据类型做到胸有成竹等等。</li><li>熟悉常用的配置，知道如何调优。</li><li>熟练配置主从。</li></ul><h4 id="NOSQL"><a href="#NOSQL" class="headerlink" title="NOSQL"></a>NOSQL</h4><ul><li>掌握Redis使用：对于常用数据结构的经典使用场景非常熟悉；了解Redis的事务、RDB、AOF等机制。</li><li>掌握memcache的使用，知道与redis的区别。</li><li>了解一下MongoDB。</li></ul><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><ul><li>熟悉常用文本命令：例如wc、awk、split、diff、grep、sed等。</li><li>熟悉sort、uniq的使用。</li><li>熟练掌握ps、netstat、top等命令使用。</li><li>熟练使用Supervisor。</li><li>熟悉如何编写shell脚本。</li><li>能够理解Nginx的配置的含义。</li></ul><h3 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h3><h4 id="PHP-1"><a href="#PHP-1" class="headerlink" title="PHP"></a>PHP</h4><ul><li>该阶段PHP已经非常熟悉了，拥有快速开发项目、快速解决BUG的能力。代码遵循psr规范、稳定性很高。</li><li>熟悉消息队列使用，在很多场景合适的选择消息队列进行异步解耦。</li><li>熟悉如何使用 Elasticsearch 代替MYSQL的全文搜索功能。</li><li>熟悉多进程编程。</li><li>熟悉socket编程，对于网络IO模型有一定的认知，熟悉多路复用(select/poll/epoll)技术。</li><li>熟悉swoole框架，能应用于项目上。</li><li>不限制于框架本身，任何框架一天内快速入手。</li><li>对php的工作机制熟悉，熟悉php-fpm生命周期。</li><li>能够知道PHP相对于c等强类型语言性能为什么会慢。</li><li>对于PHP内部的实现原理有一定的认知，例如变量的实现、zend引擎的了解。</li><li>对于PHP的扩展有一定的认知，可以编写简单的扩展。</li></ul><h4 id="MYSQL-1"><a href="#MYSQL-1" class="headerlink" title="MYSQL"></a>MYSQL</h4><ul><li>熟悉大批量的数据导入导出。对于线上大表操作可能带来的风险有预知。</li><li>熟悉分库分表。</li><li>对主从延迟能有效解决。</li><li>对于MySQL内置的一些函数能够熟练使用，熟悉触发器、存储过程的使用。</li><li>熟悉服务器核心性能优化选项 innodb_log_buffer_size、back_log、table_open_cache、thread_cache_size、innodb_lock_wait_timeout等。</li><li>对于MySQL内部索引的实现、事务隔离机制有一定的认知。</li></ul><h4 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h4><ul><li>redis常用5中数据类型之外的数据结构也要能掌握一些。如bitmap、GEO、HyperLogLog、pub/sub等。</li><li>redis里的事务、管道、分布式锁能熟练使用。</li><li>对于redis的服务端结构能有一定认知。</li><li>熟悉redis里如何使用Lua。</li><li>尝试阅读redis源码。</li></ul><h4 id="Linux-1"><a href="#Linux-1" class="headerlink" title="Linux"></a>Linux</h4><ul><li>对于nginx非常熟悉，能够熟练配置https、负载均衡、反向代理；能够使用 lua-nginx-module。</li><li>对awk/sed 等应用已经如火纯青，能够随意操作控制处理文本统计分析各种复杂格式的数据。</li><li>对于tcpdump、gdb、ltrace、strace、lsof等熟练使用。</li></ul><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><ul><li>熟悉Linux应用编程：熟悉makefile使用；熟悉进程、信号、I/O知识；对于C语言有一定的了解。</li><li>熟练elk。</li><li>对于其它语言(例如java、c、golang）、其它领域(大数据)有一定的认知。</li><li>熟悉RPC、微服务架构。</li><li>能够支持对于千万级流量网站的正常开发维护工作。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;入门阶段&quot;&gt;&lt;a href=&quot;#入门阶段&quot; class=&quot;headerlink&quot; title=&quot;入门阶段&quot;&gt;&lt;/a&gt;入门阶段&lt;/h3&gt;&lt;h4 id=&quot;预备知识&quot;&gt;&lt;a href=&quot;#预备知识&quot; class=&quot;headerlink&quot; title=&quot;预备知识&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="PHP" scheme="http://jas-wang.fun/categories/PHP/"/>
    
    
      <category term="PHP学习路线" scheme="http://jas-wang.fun/tags/PHP%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>PHP性能优化点</title>
    <link href="http://jas-wang.fun/2020/07/14/php/"/>
    <id>http://jas-wang.fun/2020/07/14/php/</id>
    <published>2020-07-14T01:52:46.000Z</published>
    <updated>2020-07-20T08:44:27.698Z</updated>
    
    <content type="html"><![CDATA[<p>摘要<br>对线上站点做压力测试的时候，我们一定要将请求数和并发数，特别是并发数要设置的比较低，我们不能对线上的网站造成压力问题，不管是自己的还是别人的。<br>PHP性能问题一般不会超过占整个项目性能的50%，一般在30%~40%。</p><hr><h4 id="PHP-性能问题的解决方向"><a href="#PHP-性能问题的解决方向" class="headerlink" title="PHP 性能问题的解决方向"></a>PHP 性能问题的解决方向</h4><h4 id="一、语言级性能优化"><a href="#一、语言级性能优化" class="headerlink" title="一、语言级性能优化"></a>一、语言级性能优化</h4><ul><li>指的是PHP语法基本功能，这部分优化比较简单易见、快速可行，比较快速看到效果</li></ul><h5 id="1-压力测试工具-Apache-Benchmark-ab"><a href="#1-压力测试工具-Apache-Benchmark-ab" class="headerlink" title="1.压力测试工具 Apache Benchmark (ab)"></a>1.压力测试工具 Apache Benchmark (ab)</h5><ul><li>ab 是由 Apache 提供的压力测试软件，安装 apache 服务器时会自带该压力测试软件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./ab -n1000 -c100 http://www.baidu.com/</span><br><span class="line">-n ：总共的请求执行数，缺省是1；</span><br><span class="line">-c： 并发数，缺省是1；</span><br><span class="line">-t：测试所进行的总时间，秒为单位，缺省50000s</span><br><span class="line">-p：POST时的数据文件</span><br><span class="line">-w: 以HTML表的格式输出结果</span><br></pre></td></tr></table></figure></li><li>参考项<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Failed requests:        0 &#x2F;&#x2F;失败的请求数量。因网络原因或服务器性能原因，发起的请求并不一定全部成功，通过该数值和Complete requests相除可以计算请求的失败率，作为测试结果的重要参考。</span><br><span class="line">Total transferred:      103314 bytes&#x2F;&#x2F;总共传输的数据量，指的是ab从被测服务器接收到的总数据量，包括index.html的文本内容和请求头信息。</span><br><span class="line">HTML transferred:       22700 bytes &#x2F;&#x2F;从服务器接收到的index.html文件的总大小，等于Document Length＊Complete requests＝227 bytes＊100＝22700 bytes</span><br><span class="line">Requests per second:    91.50 [#&#x2F;sec] (mean) &#x2F;&#x2F;平均(mean)每秒完成的请求数：QPS，这是一个平均值，等于Complete requests&#x2F;Time taken for tests&#x3D;100&#x2F;1.093&#x3D;91.50</span><br><span class="line">Time per request:       109.287 [ms] (mean) &#x2F;&#x2F;从用户角度看，完成一个请求所需要的时间（因用户数量不止一个，服务器完成10个请求，平均每个用户才接收到一个完整的返回，所以该值是下一项数值的10倍。）</span><br><span class="line">Time per request:       10.929 [ms] (mean, across all concurrent requests)&#x2F;&#x2F; 服务器完成一个请求的时间。</span><br><span class="line">Transfer rate:          92.32 [Kbytes&#x2F;sec] received&#x2F;&#x2F;网络传输速度。对于大文件的请求测试，这个值很容易成为系统瓶颈所在。要确定该值是不是瓶颈，需要了解客户端和被测服务器之间的网络情况，包括网络带宽和网卡速度等信息。</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-PHP-自身能力"><a href="#2-PHP-自身能力" class="headerlink" title="2.PHP 自身能力"></a>2.PHP 自身能力</h5><p>少写代码，多用 PHP 自身能力</p><ul><li>自身代码冗余较多，可读性不佳，并且性能低。为什么性能低：PHP 代码需要编译解释为底层语言，这一过程每次请求都会处理一遍，开销大。多使用 PHP 内置变量、常量、函数。</li></ul><p>PHP 代码运行流程</p><ul><li>php文件 -&gt; zend引擎 -&gt; [Parser] -&gt; Opcodes(要被执行的代码,目前很多 php 的缓存服务使用的都是 opcode，节省了扫描和解析的过程，提升速度。) -&gt; [Exec] =&gt; Output </li></ul><p>PHP 内置函数之间的性能测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array_key_exists() 和 isset()</span><br><span class="line">php 执行效率上： isset &gt; array_key_exists</span><br></pre></td></tr></table></figure><ul><li>当数组个数为10时，两者差异就体现出来了，isset 速度要快近10倍，但不是很明显，而且对于变量是否存在，两者之间的差异没有太大，当变量存在时运行更快，但是这种趋势在是非常微弱的。</li><li>使用 array_key_exists 随着循环的次数增加，程序运行的时间增加量是成几何级数增加的，当一个数组元素个数超过1000时运行速度就非常慢了。</li><li>由于 isset 属于 php 中的语言结构，而 array_key_exists 是函数，所以 isset 更快。</li></ul><h5 id="3-减少-PHP-魔法函数的使用"><a href="#3-减少-PHP-魔法函数的使用" class="headerlink" title="3.减少 PHP 魔法函数的使用"></a>3.减少 PHP 魔法函数的使用</h5><p>PHP自身提供的魔法函数，性能并不是很好 ,是为了给 PHP 程序员省事，PHP 语言为你做了很多，所以尽量减少魔法函数的使用。</p><h5 id="4-Linux-time命令-可以查看PHP文件的执行耗时"><a href="#4-Linux-time命令-可以查看PHP文件的执行耗时" class="headerlink" title="4.Linux time命令-可以查看PHP文件的执行耗时"></a>4.Linux time命令-可以查看PHP文件的执行耗时</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost wwwroot]# time php index.php</span><br><span class="line">real0m0.070s</span><br><span class="line">user0m0.050s (关注这个)</span><br><span class="line">sys0m0.020s</span><br></pre></td></tr></table></figure><p>在上面运行的结果中，我们只关注user的那一行时间，关于这三个时间的解释，可以参考下面的解释：</p><ul><li>real 时间是指挂钟时间，也就是命令开始执行到结束的时间。这个短时间包括其他进程所占用的时间片，和进程被阻塞时所花费的时间。</li><li>user 时间是指进程花费在用户模式中的CPU时间，这是唯一真正用于执行进程所花费的时间，其他进程和花费阻塞状态中的时间没有计算在内。</li><li>sys  时间是指花费在内核模式中的CPU时间，代表在内核中执系统调用所花费的时间，这也是真正由进程使用的CPU时间。</li></ul><h5 id="5-错误抑制符"><a href="#5-错误抑制符" class="headerlink" title="5.错误抑制符 @"></a>5.错误抑制符 @</h5><p>@的实际逻辑：在代码开始前、结束后，增加 Opcode，忽略报错<br>性能测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;at.php</span><br><span class="line">file_get_contens(&#39;xxx&#39;); &#x2F;&#x2F; 直接获取一个不存在文件的内容，此时会报错</span><br><span class="line"></span><br><span class="line">方便查看执行过程我们可以使用 vld 扩展执行at.php，查看执行过程的完整 Opcode</span><br><span class="line">php -dvld.active&#x3D;1 -dvld.execute&#x3D;0 at.php</span><br><span class="line"># 不加@错误抑制符时Opcode的执行情况</span><br><span class="line">SEND_VAL</span><br><span class="line">DO_FCALL</span><br><span class="line">RETURN</span><br><span class="line"># 加@错误抑制符时Opcode的执行情况</span><br><span class="line">BEGIN_SILENCE</span><br><span class="line">SEND_VAL</span><br><span class="line">DO_FCALL</span><br><span class="line">END_SILENCE</span><br><span class="line">RETURN</span><br></pre></td></tr></table></figure><p>建议：可以使用 try throw 方式进行错误控制</p><h5 id="6-合理使用内存"><a href="#6-合理使用内存" class="headerlink" title="6.合理使用内存"></a>6.合理使用内存</h5><p>PHP 有内存回收机制保底，但也要小心使用内存 利用 unset()及时释放不使用的内存</p><h5 id="7-避免在循环内做运算"><a href="#7-避免在循环内做运算" class="headerlink" title="7.避免在循环内做运算"></a>7.避免在循环内做运算</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">优化前</span><br><span class="line">$str &#x3D; &quot;hello world&quot;;</span><br><span class="line">for ($i&#x3D;0; $i &lt; strlen($str); $i++) &#123;</span><br><span class="line">    # code...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 其中strlen()方法会在每次循环时计算一次</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 进行优化</span><br><span class="line">$str &#x3D; &quot;hello world&quot;;</span><br><span class="line">$strlen &#x3D; strlen($str);</span><br><span class="line">for ($i&#x3D;0; $i &lt; $strlen; $i++) &#123;</span><br><span class="line">    # code...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="8-务必适用带引号字符串做键值"><a href="#8-务必适用带引号字符串做键值" class="headerlink" title="8.务必适用带引号字符串做键值"></a>8.务必适用带引号字符串做键值</h5><p>PHP 会将没有引号的键值当做常量，产生查找常量的开销</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define(&#39;key&#39;, &#39;test&#39;);</span><br><span class="line"></span><br><span class="line">$array &#x3D; array(</span><br><span class="line">    &#39;key&#39; &#x3D;&gt; &#39;1&#39;,</span><br><span class="line">    &#39;test&#39; &#x3D;&gt; &#39;2&#39;</span><br><span class="line">);</span><br><span class="line">echo $array[&quot;key&quot;] . &#39;\n&#39;; &#x2F;&#x2F; 输出 1</span><br><span class="line">echo $array[key] . &#39;\n&#39;; &#x2F;&#x2F; 输出 2</span><br></pre></td></tr></table></figure><p>当时用$array[key]时，程序也把 key 作为常量去查找，当查找到时，获取到常量的值；当没查找到时，再到数组内部，将其作为键 key 字符串进行解析</p><h4 id="二、PHP-周边环境影响"><a href="#二、PHP-周边环境影响" class="headerlink" title="二、PHP 周边环境影响"></a>二、PHP 周边环境影响</h4><h5 id="1-运行环境"><a href="#1-运行环境" class="headerlink" title="1.运行环境"></a>1.运行环境</h5><ul><li>Linux运行环境</li><li>文件存储 （读写磁盘，数据库，内存，网络数据）</li><li>数据库</li><li>缓存 【内存，PHP缓存技术，redis】</li><li>网络</li></ul><p>优化方向</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-读写内存 &lt;&lt;(远小于) 读写数据库[基于文件系统，操作本地磁盘] &lt;(小于) 读写磁盘 &lt; 读写网络数据</span><br><span class="line"></span><br><span class="line">-数据库会使用内存作为缓存，将其热数据先缓存在内存中，异步地写入到数据库 &#x3D;&gt; 数据库介于内存和磁盘之间</span><br><span class="line"></span><br><span class="line">-网络数据：通过socket发起，socket使用的是本地的文件句柄，磁盘操作。受网络延迟影响， 延迟大时远远</span><br><span class="line">小于读写磁盘，延迟小时和读写磁盘差不多。</span><br></pre></td></tr></table></figure><p>建议：尽可能多的使用读写数据库、读写内存，尽量规避操作磁盘和操作网络数据。</p><h5 id="2-优化网络请求"><a href="#2-优化网络请求" class="headerlink" title="2.优化网络请求"></a>2.优化网络请求</h5><p>(1).网络请求的坑：对方接口的不确定因素 ,网络的稳定性<br>(2).如何优化网络请求？</p><ul><li>设置超时时间：（连接超时，读超时，写超时）</li><li>将串行请求并行化：使用 curlmulti*() =&gt; 最简单，但是并不是最好用；使用 swoole 扩展 =&gt; 效果更好<br><a href="https://www.cnblogs.com/52fhy/p/8908315.html" target="_blank" rel="noopener">curl_multi实现并发列子</a></li></ul><h5 id="3-开启PHP慢日志查询"><a href="#3-开启PHP慢日志查询" class="headerlink" title="3.开启PHP慢日志查询"></a>3.开启PHP慢日志查询</h5><ul><li>找到php-fpm.conf文件</li><li>去掉request_slowlog_timeout前面的分号，并设置时间。如：request_slowlog_timeout=5表示超过5秒的</li><li>慢日志文件位置默认在php的安装目录下的log文件夹中，可以通过修改slowlog = log/$pool.log.slow参数来指定。</li><li>php-fpm慢日志的例子，慢日志会记录下进程号，脚本名称，具体哪个文件哪行代码的哪个函数执行时间过长。</li><li>request_slowlog_timeout 和 slowlog需要同时设置，开启request_slowlog_timeout的同时需要开启 slowlog</li><li>慢日志路径需要手动创建 (slowlog)</li></ul><h5 id="4-借助-xhprof-工具分析-PHP-性能"><a href="#4-借助-xhprof-工具分析-PHP-性能" class="headerlink" title="4.借助 xhprof 工具分析 PHP 性能"></a>4.借助 xhprof 工具分析 PHP 性能</h5><p><a href="/2020/07/20/php-xhprof/">php-性能分析工具-xhprof</a></p><h4 id="三、-PHP-性能瓶颈终极办法"><a href="#三、-PHP-性能瓶颈终极办法" class="headerlink" title="三、 PHP 性能瓶颈终极办法"></a>三、 PHP 性能瓶颈终极办法</h4><h5 id="1-APC-Alternative-PHP-Cache"><a href="#1-APC-Alternative-PHP-Cache" class="headerlink" title="1.APC (Alternative PHP Cache)"></a>1.APC (Alternative PHP Cache)</h5><ul><li>是一款开源的php插件,用来对php的代码或者用户数据进行缓存。</li><li>apc可以去掉php动态解析以及编译的时间，php脚本可以执行的更快。</li><li>PHP是一个动态脚本语言，所以为了让用户在浏览器中看到页面内容，服务器必须解析php代码从而生成想用的html代码。从上面的图中可以看出，在没有apc的时候，用户对php页面的每一次请求，服务器都需要进行对php进行解析，编译以及执行，但是很多时候，只要php代码没有发生更改，php的执行逻辑就不会改变，也就是说解析以及编译的过程就可以省略，直接执行然后将结果返回即可。这就是apc的工作，apc缓存php的可执行代码，从而去掉了解析以及编译的过程，加快了php脚本的执行速度。</li><li>缓存数据量小，大的话建议redis或者memcache</li></ul><p>这里有一个简单的例子对比redis 和 apc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function getTimeStamp() &#123;  </span><br><span class="line">  $timestr &#x3D; microtime();  </span><br><span class="line">  $timestrary &#x3D; explode(&#39; &#39;, $timestr);  </span><br><span class="line">  $result &#x3D; intval($timestrary[1])*1000 + intval(floatval($timestrary[0])*1000);  </span><br><span class="line">  return $result;  </span><br><span class="line">&#125;   </span><br><span class="line">$redis &#x3D; new Redis();  </span><br><span class="line">$redis-&gt;connect(&#39;127.0.0.1&#39;, 6379);  </span><br><span class="line">$key &#x3D; &#39;key&#39;;  </span><br><span class="line">$value &#x3D;&#39;value&#39;;  </span><br><span class="line">$redis-&gt;set($key, $value);  </span><br><span class="line">    </span><br><span class="line">apc_store($key, $value, 1);   </span><br><span class="line">    </span><br><span class="line">$begin &#x3D; getTimeStamp();  </span><br><span class="line">for($i &#x3D; 0 ; $i &lt; 100000 ; $i &#x3D; $i +1) &#123;  </span><br><span class="line">  $result &#x3D; apc_fetch($key);  </span><br><span class="line">&#125;   </span><br><span class="line">$cost &#x3D; getTimeStamp() - $begin;  </span><br><span class="line">var_dump($cost);  </span><br><span class="line">$begin &#x3D; getTimeStamp();  </span><br><span class="line">for($i &#x3D; 0 ; $i &lt; 100000 ; $i &#x3D; $i +1) &#123;  </span><br><span class="line">  $result &#x3D; $redis-&gt;get($key);  </span><br><span class="line">&#125;   </span><br><span class="line">$cost &#x3D; getTimeStamp() - $begin;  </span><br><span class="line">var_dump($cost);  </span><br><span class="line">$redis-&gt;close();</span><br></pre></td></tr></table></figure><p>都是简单的取数据操作，分别进行10万次，单位是毫秒。最后的运行结果redis10万次读在4-5秒之间，而apc得10万次读只有50毫秒左右。可以看到如果是简单的缓存一些数据，并且这些数据不会变化且命中的话，apc还是能带来一定的效率提升的。</p><p>apc php.ini 配置参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extension&#x3D; apc.so   &#x2F;&#x2F;添加扩展</span><br><span class="line">apc.enabled&#x3D;1   &#x2F;&#x2F;开启apc</span><br><span class="line">apc.shm_segments&#x3D;1   </span><br><span class="line">apc.shm_size&#x3D;64M ; apc内存的大小,最后的大小需要乘上segments的数量，所以这里一共为apc分配64M   </span><br><span class="line">apc.ttl&#x3D;7200   </span><br><span class="line">apc.user_ttl&#x3D;7200  </span><br><span class="line">apc.enable_cli&#x3D;1 ; 这个如果不开启，则只可以在网页上进行apc操作，不能通过cli进行apc操作</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要&lt;br&gt;对线上站点做压力测试的时候，我们一定要将请求数和并发数，特别是并发数要设置的比较低，我们不能对线上的网站造成压力问题，不管是自己的还是别人的。&lt;br&gt;PHP性能问题一般不会超过占整个项目性能的50%，一般在30%~40%。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;PH
      
    
    </summary>
    
    
      <category term="PHP" scheme="http://jas-wang.fun/categories/PHP/"/>
    
    
      <category term="php底层优化" scheme="http://jas-wang.fun/tags/php%E5%BA%95%E5%B1%82%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
