<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>1</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jas-wang.fun/"/>
  <updated>2020-07-22T00:49:54.803Z</updated>
  <id>http://jas-wang.fun/</id>
  
  <author>
    <name>Jas wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常见问题以及解决办法【持续更新中...】</title>
    <link href="http://jas-wang.fun/2020/07/22/question/"/>
    <id>http://jas-wang.fun/2020/07/22/question/</id>
    <published>2020-07-22T01:52:46.000Z</published>
    <updated>2020-07-22T00:49:54.803Z</updated>
    
    <content type="html"><![CDATA[<p>摘要<br>这里收集了PHP中经常遇到的问题和解决的办法,遇到了就会添加进来</p><hr><h5 id="高并发下如何防止修改同一条数据？"><a href="#高并发下如何防止修改同一条数据？" class="headerlink" title="高并发下如何防止修改同一条数据？"></a>高并发下如何防止修改同一条数据？</h5><p>解决方案：</p><ul><li>使用悲观锁</li></ul><p>悲观锁本质是当前只有一个线程执行操作，排斥外部请求的修改。遇到加锁的状态，就必须等待。<br>结束了唤醒其他线程进行处理。虽然此方案的确解决了数据安全的问题，<br>但是，我们的场景是“高并发”。也就是说，会很多这样的修改请求，每个请求都需要等待“锁”，<br>某些线程可能永远都没有机会抢到这个“锁”，这种请求就会死在那里。<br>同时，这种请求会很多，瞬间增大系统的平均响应时间，结果是可用连接数被耗尽，系统陷入异常。<br>可以举个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">使用MySQL的事务，锁住操作的行</span><br><span class="line">&#x2F;&#x2F;库存是否大于0</span><br><span class="line">mysqli_query($conn,&quot;BEGIN&quot;);  &#x2F;&#x2F;开始事务</span><br><span class="line">$sql&#x3D;&quot;select number from xxxx FOR UPDATE&quot;;&#x2F;&#x2F;此时这条记录被锁住,其它事务必须等待此次事务提交后才能执行</span><br><span class="line">$rs&#x3D;mysqli_query($conn,$sql);</span><br><span class="line">$row&#x3D;$rs-&gt;fetch_assoc();</span><br><span class="line">if($row[&#39;number&#39;]&gt;0)&#123;</span><br><span class="line">    &#x2F;&#x2F;库存减少</span><br><span class="line">    $sql&#x3D;&quot;update ih_store set number&#x3D;number-&#123;$number&#125; where sku_id&#x3D;&#39;$sku_id&#39;&quot;;</span><br><span class="line">    $store_rs&#x3D;mysqli_query($conn,$sql);</span><br><span class="line">    if($store_rs)&#123;</span><br><span class="line">      echo &#39;库存减少成功&#39;;    </span><br><span class="line">        mysqli_query($conn,&quot;COMMIT&quot;);&#x2F;&#x2F;事务提交即解锁</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      echo &#39;库存减少失败&#39;;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">  echo &#39;库存不够&#39;;</span><br><span class="line">    mysqli_query($conn,&quot;ROLLBACK&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用乐观锁<br>乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。<br>悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。<br>但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。而乐观锁机制在一定程度上解决了这个问题。<br>乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，<br>一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。<br>此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，<br>则予以更新，否则不允许更新。<br>有很多软件和服务都“乐观锁”功能的支持，例如Redis中的watch就是其中之一。通过这个实现，我们保证了数据的安全。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$redis &#x3D; new redis();</span><br><span class="line"> $result &#x3D; $redis-&gt;connect(&#39;127.0.0.1&#39;, 6379);</span><br><span class="line"> echo $mywatchkey &#x3D; $redis-&gt;get(&quot;mywatchkey&quot;);</span><br><span class="line"></span><br><span class="line">$rob_total &#x3D; 100;   &#x2F;&#x2F;抢购数量</span><br><span class="line">if($mywatchkey&lt;&#x3D;$rob_total)&#123;</span><br><span class="line">    $redis-&gt;watch(&quot;mywatchkey&quot;);</span><br><span class="line">    $redis-&gt;multi(); &#x2F;&#x2F;在当前连接上启动一个新的事务。</span><br><span class="line">    &#x2F;&#x2F;插入抢购数据</span><br><span class="line">    $redis-&gt;set(&quot;mywatchkey&quot;,$mywatchkey+1);</span><br><span class="line">    $rob_result &#x3D; $redis-&gt;exec();</span><br><span class="line">    if($rob_result)&#123;</span><br><span class="line">         $redis-&gt;hSet(&quot;watchkeylist&quot;,&quot;user_&quot;.mt_rand(1, 9999),$mywatchkey);</span><br><span class="line">        $mywatchlist &#x3D; $redis-&gt;hGetAll(&quot;watchkeylist&quot;);</span><br><span class="line">        echo &quot;抢购成功！&lt;br&#x2F;&gt;&quot;;</span><br><span class="line">     </span><br><span class="line">        echo &quot;剩余数量：&quot;.($rob_total-$mywatchkey-1).&quot;&lt;br&#x2F;&gt;&quot;;</span><br><span class="line">        echo &quot;用户列表：&lt;pre&gt;&quot;;</span><br><span class="line">        var_dump($mywatchlist);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">          $redis-&gt;hSet(&quot;watchkeylist&quot;,&quot;user_&quot;.mt_rand(1, 9999),&#39;meiqiangdao&#39;);</span><br><span class="line">        echo &quot;手气不好，再抢购！&quot;;exit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="Redis相比memcached有哪些优势？"><a href="#Redis相比memcached有哪些优势？" class="headerlink" title="Redis相比memcached有哪些优势？"></a>Redis相比memcached有哪些优势？</h5><p>解决方案：</p><ul><li><p>memcached所有的值均是简单的字符串，Redis作为其替代者，支持更为丰富的数据类型</p></li><li><p>Redis的速度比memcached快很多</p></li><li><p>Redis可以持久化其数据</p></li><li><p>Redis支持数据的备份，即master-slave模式的数据备份。</p></li></ul><h5 id="Redis提供了哪几种持久化方式？"><a href="#Redis提供了哪几种持久化方式？" class="headerlink" title="Redis提供了哪几种持久化方式？"></a>Redis提供了哪几种持久化方式？</h5><p>解决方案：<br> Redis主要提供了两种持久化机制：RDB和AOF；</p><ul><li><p>RDB</p><p>默认开启，会按照配置的指定时间将内存中的数据快照到磁盘中，创建一个dump.rdb文件，Redis启动时再恢复到内存中。</p><p>Redis会单独创建fork()一个子进程，将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。</p><p>需要注意的是，每次快照持久化都会将主进程的数据库数据复制一遍，导致内存开销加倍，若此时内存不足，则会阻塞服务器运行，直到复制结束释放内存；都会将内存数据完整写入磁盘一次，所以如果数据量大的话，而且写操作频繁，必然会引起大量的磁盘I/O操作，严重影响性能，并且最后一次持久化后的数据可能会丢失；</p></li><li><p>AOF</p><p>以日志的形式记录每个写操作（读操作不记录），只需追加文件但不可以改写文件，Redis启动时会根据日志从头到尾全部执行一遍以完成数据的恢复工作。包括flushDB也会执行。</p><p>主要有两种方式触发：有写操作就写、每秒定时写（也会丢数据）。</p><p>因为AOF采用追加的方式，所以文件会越来越大，针对这个问题，新增了重写机制，就是当日志文件大到一定程度的时候，会fork出一条新进程来遍历进程内存中的数据，每条记录对应一条set语句，写到临时文件中，然后再替换到旧的日志文件（类似rdb的操作方式）。默认触发是当aof文件大小是上次重写后大小的一倍且文件大于64M时触发。</p><p>当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。一般情况下，只要使用默认开启的RDB即可，因为相对于AOF，RDB便于进行数据库备份，并且恢复数据集的速度也要快很多。</p><p>开启持久化缓存机制，对性能会有一定的影响，特别是当设置的内存满了的时候，更是下降到几百reqs/s。所以如果只是用来做缓存的话，可以关掉持久化。</p></li></ul><h5 id="多线程写入同一个文件的时候，如何解决“线程安全”的问题？"><a href="#多线程写入同一个文件的时候，如何解决“线程安全”的问题？" class="headerlink" title="多线程写入同一个文件的时候，如何解决“线程安全”的问题？"></a>多线程写入同一个文件的时候，如何解决“线程安全”的问题？</h5><p>解决方案：<br> 首先什么是线程安全？多个线程同时运行同一段代码，如果每次运行结果和单线程运行的结果是一样的，结果和预期相同，就是线程安全的）。<br> 如果是MySQL数据库，可以使用它自带的锁机制很好的解决问题。<br> 但是，在大规模并发的场景中，是不推荐使用MySQL的。<br>举例如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (flock($file,LOCK_EX)) &#123;</span><br><span class="line">  fwrite($file,&#39;write something&#39;);</span><br><span class="line">  flock($file,LOCK_UN);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">  echo &#39;locked&#39;;</span><br><span class="line">&#125;</span><br><span class="line">fclose($file);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要&lt;br&gt;这里收集了PHP中经常遇到的问题和解决的办法,遇到了就会添加进来&lt;/p&gt;
&lt;hr&gt;
&lt;h5 id=&quot;高并发下如何防止修改同一条数据？&quot;&gt;&lt;a href=&quot;#高并发下如何防止修改同一条数据？&quot; class=&quot;headerlink&quot; title=&quot;高并发下如何防止修
      
    
    </summary>
    
    
      <category term="PHP" scheme="http://jas-wang.fun/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://jas-wang.fun/tags/PHP/"/>
    
      <category term="MySQL" scheme="http://jas-wang.fun/tags/MySQL/"/>
    
      <category term="高并发" scheme="http://jas-wang.fun/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux-常用命令</title>
    <link href="http://jas-wang.fun/2020/07/21/linux/"/>
    <id>http://jas-wang.fun/2020/07/21/linux/</id>
    <published>2020-07-21T01:00:46.000Z</published>
    <updated>2020-07-21T03:24:53.228Z</updated>
    
    <content type="html"><![CDATA[<p>摘要<br>Linux 常用命令学习</p><hr><h5 id="1-find-命令用来在指定目录下查找文件。"><a href="#1-find-命令用来在指定目录下查找文件。" class="headerlink" title="1. find -命令用来在指定目录下查找文件。"></a>1. find -命令用来在指定目录下查找文件。</h5><p>任何位于参数之前的字符串都将被视为欲查找的目录名。<br>如果使用该命令时，不设置任何参数，则 find 命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。<br>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">find   path   -option   [   -print ]   [ -exec   -ok   command ]   &#123;&#125; \;</span><br><span class="line"></span><br><span class="line">-name 按名字查找</span><br><span class="line">-perm 根据权限查找</span><br><span class="line">-ctime –n +m 根据创建时间查找，-n n天内，+n n天之前</span><br><span class="line">-mtime –n +n 最后修改时间</span><br><span class="line">-exec command &#123;&#125; \; 对每条记录执行command</span><br><span class="line">-ok command &#123;&#125;\;同上</span><br><span class="line">例：find . –name “*.log” –exec ls –al &#123;&#125; \;</span><br><span class="line">find &#x2F;var -name &quot;*.log&quot; -mtime +10 -exec ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">将目前目录及其子目录下所有延伸档名是 c 的文件列出来。</span><br><span class="line"># find . -name &quot;*.c&quot;</span><br><span class="line">将目前目录其其下子目录中所有一般文件列出</span><br><span class="line"># find . -type f</span><br><span class="line">将目前目录及其子目录下所有最近 20 天内更新过的文件列出</span><br><span class="line"># find . -ctime -20</span><br><span class="line">查找&#x2F;var&#x2F;log目录中更改时间在7日以前的普通文件，并在删除之前询问它们：</span><br><span class="line"># find &#x2F;var&#x2F;log -type f -mtime +7 -ok rm &#123;&#125; \;</span><br><span class="line">查找前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件：</span><br><span class="line"># find . -type f -perm 644 -exec ls -l &#123;&#125; \;</span><br><span class="line">为了查找系统中所有文件长度为0的普通文件，并列出它们的完整路径：</span><br><span class="line"># find &#x2F; -type f -size 0 -exec ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure><h5 id="2-grep-命令用于查找文件里符合条件的字符串"><a href="#2-grep-命令用于查找文件里符合条件的字符串" class="headerlink" title="2. grep 命令用于查找文件里符合条件的字符串"></a>2. grep 命令用于查找文件里符合条件的字符串</h5><p>如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。<br>若不指定任何文件名称，或是所给予的文件名为 -，则 grep 指令会从标准输入设备读取数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">grep –c “sdf” *.txt 只返回匹配的行数</span><br><span class="line">grep –n 输出行号</span><br><span class="line">grep “2010-5-1[0-9]” myfile 10号到19号的</span><br><span class="line">grep “^[^123]” myfile 不是以1，2，3大头的</span><br><span class="line">grep “4\&#123;2\&#125;” myfile 连续2个4</span><br><span class="line">grep “4\&#123;2,\&#125;” myfile 连续至少2个4</span><br><span class="line">grep “4\&#123;2,5\&#125;” myfile 连续2到5个4</span><br><span class="line">grep “^$” myfile 空行</span><br><span class="line">grep “\^” myfile 查找^符号，用\过滤掉转义</span><br></pre></td></tr></table></figure><h5 id="3-wc命令用于计算字数"><a href="#3-wc命令用于计算字数" class="headerlink" title="3.  wc命令用于计算字数"></a>3.  wc命令用于计算字数</h5><p>利用wc指令我们可以计算文件的Byte数、字数、或是列数，若不指定文件名称、或是所给予的文件名为”-“，则wc指令会从标准输入设备读取数据<br>语法<br>wc [-clw][–help][–version][文件…]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">参数：</span><br><span class="line">-c或--bytes或--chars 只显示Bytes数。</span><br><span class="line">-l或--lines 只显示行数。</span><br><span class="line">-w或--words 只显示字数。</span><br><span class="line">--help 在线帮助。</span><br><span class="line">--version 显示版本信息。</span><br></pre></td></tr></table></figure><p>实例<br>在默认的情况下，wc将计算指定文件的行数、字数，以及字节数。使用的命令为：<br>使用 wc统计，结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wc testfile           # testfile文件的统计信息  </span><br><span class="line">3 92 598 testfile       # testfile文件的行数为3、单词数92、字节数598</span><br></pre></td></tr></table></figure><h5 id="4-awk（很好很强大）"><a href="#4-awk（很好很强大）" class="headerlink" title="4. awk（很好很强大）"></a>4. awk（很好很强大）</h5><p>AWK 是一种处理文本文件的语言，是一个强大的文本分析工具。</p><p>选项参数说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-F fs or --field-separator fs</span><br><span class="line">指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:。</span><br><span class="line">-v var&#x3D;value or --asign var&#x3D;value</span><br><span class="line">赋值一个用户定义变量。</span><br><span class="line">-f scripfile or --file scriptfile</span><br><span class="line">从脚本文件中读取awk命令。</span><br><span class="line">-mf nnn and -mr nnn</span><br><span class="line">对nnn值设置内在限制，-mf选项限制分配给nnn的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。</span><br><span class="line">-W compact or --compat, -W traditional or --traditional</span><br><span class="line">在兼容模式下运行awk。所以gawk的行为和标准的awk完全一样，所有的awk扩展都被忽略。</span><br><span class="line">-W copyleft or --copyleft, -W copyright or --copyright</span><br><span class="line">打印简短的版权信息。</span><br><span class="line">-W help or --help, -W usage or --usage</span><br><span class="line">打印全部awk选项和每个选项的简短说明。</span><br><span class="line">-W lint or --lint</span><br><span class="line">打印不能向传统unix平台移植的结构的警告。</span><br><span class="line">-W lint-old or --lint-old</span><br><span class="line">打印关于不能向传统unix平台移植的结构的警告。</span><br><span class="line">-W posix</span><br><span class="line">打开兼容模式。但有以下限制，不识别：&#x2F;x、函数关键字、func、换码序列以及当fs是一个空格时，将新行作为一个域分隔符；操作符**和**&#x3D;不能代替^和^&#x3D;；fflush无效。</span><br><span class="line">-W re-interval or --re-inerval</span><br><span class="line">允许间隔正则表达式的使用，参考(grep中的Posix字符类)，如括号表达式[[:alpha:]]。</span><br><span class="line">-W source program-text or --source program-text</span><br><span class="line">使用program-text作为源代码，可与-f命令混用。</span><br><span class="line">-W version or --version</span><br></pre></td></tr></table></figure><p>基本用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">新建 log.txt文本内容如下：</span><br><span class="line">2 this is a test</span><br><span class="line">3 Are you like awk</span><br><span class="line">This&#39;s a test</span><br><span class="line">10 There are orange,apple,mongo</span><br><span class="line">---------------------------------------------</span><br><span class="line">每行按空格或TAB分割，输出文本中的1、4项</span><br><span class="line">$ awk &#39;&#123;print $1,$4&#125;&#39; log.txt</span><br><span class="line">---------------------------------------------</span><br><span class="line"> 2 a</span><br><span class="line"> 3 like</span><br><span class="line"> This&#39;s</span><br><span class="line"> 10 orange,apple,mongo</span><br></pre></td></tr></table></figure><h5 id="5-sed-命令是利用脚本来处理文本文件。"><a href="#5-sed-命令是利用脚本来处理文本文件。" class="headerlink" title="5. sed 命令是利用脚本来处理文本文件。"></a>5. sed 命令是利用脚本来处理文本文件。</h5><p>sed 可依照脚本的指令来处理、编辑文本文件。<br>Sed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sed -e 4a\newline testfile #使用sed 在第四行后添加新字符串  </span><br><span class="line">HELLO LINUX! #testfile文件原有的内容  </span><br><span class="line">Linux is a free unix-type opterating system.  </span><br><span class="line">This is a linux testfile!  </span><br><span class="line">Linux test  </span><br><span class="line">newline</span><br></pre></td></tr></table></figure><h5 id="6-sort-排序命令"><a href="#6-sort-排序命令" class="headerlink" title="6. sort 排序命令"></a>6. sort 排序命令</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-c 检查文件是否已排序</span><br><span class="line">-u unique的意思，排序后重复记录只显示一条</span><br><span class="line">-r reverse,反序</span><br><span class="line">-n 数字排序</span><br><span class="line">-kn 按第n个域进行排序，相当于+ n-1 –n，现在推荐用-k</span><br><span class="line">--------------------------------------------------</span><br><span class="line">sort -t: -k3 messages | head 等同于sort -t: +2 -3 messages | head</span><br></pre></td></tr></table></figure><h5 id="7-Linux-uniq-命令用于检查及删除文本文件中重复出现的行列，一般与-sort-命令结合使用。"><a href="#7-Linux-uniq-命令用于检查及删除文本文件中重复出现的行列，一般与-sort-命令结合使用。" class="headerlink" title="7. Linux uniq 命令用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用。"></a>7. Linux uniq 命令用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用。</h5><p>从一个文本中去除或禁止重复行，这里的重复行指的是相邻的！可与sort结合使用。<br>实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-c 显示每条记录重复的行数</span><br><span class="line">-u 只显示不重复的行，即-c为1的那些行</span><br><span class="line">-d只显示记录重复的行，但每条只显示1次</span><br><span class="line"></span><br><span class="line">--------------------------------------------------</span><br><span class="line">$ uniq -c testfile      #删除重复行后的内容  </span><br><span class="line">3 test 30             #前面的数字的意义为该行共出现了3次  </span><br><span class="line">4 Hello 95            #前面的数字的意义为该行共出现了4次  </span><br><span class="line">2 Linux 85            #前面的数字的意义为该行共出现了2次</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要&lt;br&gt;Linux 常用命令学习&lt;/p&gt;
&lt;hr&gt;
&lt;h5 id=&quot;1-find-命令用来在指定目录下查找文件。&quot;&gt;&lt;a href=&quot;#1-find-命令用来在指定目录下查找文件。&quot; class=&quot;headerlink&quot; title=&quot;1. find -命令用来在指定目
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://jas-wang.fun/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://jas-wang.fun/tags/Linux/"/>
    
      <category term="服务器" scheme="http://jas-wang.fun/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>PHP常用设计模式</title>
    <link href="http://jas-wang.fun/2020/07/17/php-design/"/>
    <id>http://jas-wang.fun/2020/07/17/php-design/</id>
    <published>2020-07-17T01:52:46.000Z</published>
    <updated>2020-07-22T00:49:11.688Z</updated>
    
    <content type="html"><![CDATA[<h5 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h5><p>(PHP 5 &gt;= 5.3.0, PHP 7)<br>什么是命名空间？从广义上来说，命名空间是一种封装事物的方法。在很多地方都可以见到这种抽象概念。<br>例如，在操作系统中目录用来将相关文件分组，对于目录中的文件来说，它就扮演了命名空间的角色。具体举个例子，<br>文件 foo.txt 可以同时在目录/home/greg 和 /home/other 中存在，但在同一个目录中不能存在两个 foo.txt 文件。<br>另外，在目录 /home/greg 外访问 foo.txt 文件时，我们必须将目录名以及目录分隔符放在文件名之前得到 /home/greg/foo.txt。<br>这个原理应用到程序设计领域就是命名空间的概念。</p><p>在PHP中，命名空间用来解决在编写类库或应用程序时创建可重用的代码如类或函数时碰到的两类问题：</p><ul><li>用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。</li><li>为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高源代码的可读性。<br>PHP 命名空间提供了一种将相关的类、函数和常量组合到一起的途径。下面是一个说明 PHP 命名空间语法的示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace my\name; &#x2F;&#x2F; 参考 &quot;定义命名空间&quot; 小节</span><br><span class="line">class MyClass &#123;&#125;</span><br><span class="line">function myfunction() &#123;&#125;</span><br><span class="line">const MYCONST &#x3D; 1;</span><br><span class="line"></span><br><span class="line">$a &#x3D; new MyClass;</span><br><span class="line">$c &#x3D; new \my\name\MyClass; &#x2F;&#x2F; 参考 &quot;全局空间&quot; 小节</span><br><span class="line"></span><br><span class="line">$a &#x3D; strlen(&#39;hi&#39;); &#x2F;&#x2F; 参考 &quot;使用命名空间：后备全局函数&#x2F;常量&quot; 小节</span><br><span class="line">$d &#x3D; namespace\MYCONST; &#x2F;&#x2F; 参考 &quot;namespace操作符和__NAMESPACE__常量” 小节</span><br><span class="line"></span><br><span class="line">$d &#x3D; __NAMESPACE__ . &#39;\MYCONST&#39;;</span><br><span class="line">echo constant($d); &#x2F;&#x2F; 参考 &quot;命名空间和动态语言特征&quot; 小节</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h5 id="类的自动载入"><a href="#类的自动载入" class="headerlink" title="类的自动载入"></a>类的自动载入</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">&#x2F;&#x2F; 老的版本 ：require&#x2F;inclue 方便当类删除的时候，避免致命错误！</span><br><span class="line">&#x2F;&#x2F; spl_autoload_register() - 注册给定的函数作为 __autoload 的实现</span><br><span class="line">class Test1&#123;</span><br><span class="line">  static  function test()&#123;</span><br><span class="line">        echo __FILE__;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">spl_autoload_register(function ($class)&#123;</span><br><span class="line">    require __DIR__.&#39;&#x2F;&#39;.$class.&#39;.php&#39;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Test1::test();</span><br></pre></td></tr></table></figure></li></ul><h5 id="PSR-0规范-弃用"><a href="#PSR-0规范-弃用" class="headerlink" title="PSR-0规范 [弃用]"></a>PSR-0规范 [弃用]</h5><ul><li>命名空间必须与绝对路径一致</li><li>类名首字母必须大写</li><li>除了入口文件外，其他‘.php’ 必须只有一个类</li></ul><h5 id="SPL标准库"><a href="#SPL标准库" class="headerlink" title="SPL标准库"></a>SPL标准库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;php 栈 先进后出</span><br><span class="line">$stack &#x3D; new SplStack();</span><br><span class="line">$stack-&gt;push(&#39;1&#39;);</span><br><span class="line">$stack-&gt;push(&#39;2&#39;);</span><br><span class="line">echo $stack-&gt;pop();</span><br><span class="line">echo $stack-&gt;pop();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;php 队列 先进先出</span><br><span class="line">$queque&#x3D; new SplQueue();</span><br><span class="line">$queque-&gt;enqueue(&#39;1&#39;);</span><br><span class="line">$queque-&gt;enqueue(&#39;2&#39;);</span><br><span class="line"></span><br><span class="line">echo $queque-&gt;dequeue();</span><br><span class="line">echo $queque-&gt;dequeue();</span><br><span class="line">&#x2F;&#x2F;php 堆 先进先出</span><br><span class="line">$heap&#x3D; new SplMinHeap();</span><br><span class="line">$heap-&gt;insert(&#39;1&#39;);</span><br><span class="line">$heap-&gt;insert(&#39;2&#39;);</span><br><span class="line"></span><br><span class="line">echo $heap-&gt;extract();</span><br><span class="line">echo $heap-&gt;extract();</span><br></pre></td></tr></table></figure><h5 id="魔术方法的使用，链式操作"><a href="#魔术方法的使用，链式操作" class="headerlink" title="魔术方法的使用，链式操作"></a>魔术方法的使用，链式操作</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;链式操作</span><br><span class="line">$db &#x3D; new Spring\Database;</span><br><span class="line">$db-&gt;where([&#39;eq&#39;&#x3D;&gt;1])-&gt;limit([&#39;1&#39;])-&gt;order([&#39;id&#39;&#x3D;&gt;&#39;asc&#39;]);</span><br><span class="line">方法体里面直接return $this;</span><br><span class="line">function where($where)</span><br><span class="line">&#123;</span><br><span class="line">  print_r($where);</span><br><span class="line">  return $this;</span><br><span class="line">&#125;</span><br><span class="line">$obj-&gt;title &#x3D; &#39;aaa&#39;;&#x2F;&#x2F; function __set()&#123;&#125;  function __get()&#123;&#125; 不存在的时候会调用的方法</span><br><span class="line">$obj-&gt;test(&#39;adsa&#39;,111); function __call()&#123;&#125;</span><br><span class="line">echo $obj();            function __toString();</span><br></pre></td></tr></table></figure><h5 id="常见的设计模式"><a href="#常见的设计模式" class="headerlink" title="常见的设计模式"></a>常见的设计模式</h5><h5 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">* -工厂方法或者类生成对象，而不是在代码中直接new</span><br><span class="line">&lt;?php</span><br><span class="line">&#x2F;**</span><br><span class="line">* 工厂模式</span><br><span class="line">*&#x2F;</span><br><span class="line">namespace Spring;</span><br><span class="line"></span><br><span class="line">class Factory</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 多个地方同时实例化的时候，当有参数变化的时候，方便修改</span><br><span class="line">    static function createDatabase()</span><br><span class="line">    &#123;</span><br><span class="line">        $db &#x3D; new Database();</span><br><span class="line">        return $db;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;调用  不用实列话</span><br><span class="line">\Spring\Factory::createDatabase();</span><br></pre></td></tr></table></figure><h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><ul><li>-使某个类的对象只允许创建一次，避免资源浪费</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private static $instance;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;private 不能直接new</span><br><span class="line">private function __construct()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static function getInstance()</span><br><span class="line">&#123;</span><br><span class="line">    if (!(self::$instance instanceof self)) &#123;</span><br><span class="line">        self::$instance &#x3D; new self();</span><br><span class="line">    &#125;</span><br><span class="line">    return self::$instance;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;调用</span><br><span class="line">\Spring\Database::getInstance()</span><br></pre></td></tr></table></figure><h5 id="注册树模式"><a href="#注册树模式" class="headerlink" title="注册树模式"></a>注册树模式</h5><ul><li>-全局共享和交换对象，可以用来被任何地方访问<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">&#x2F;**</span><br><span class="line">* 注册树模式</span><br><span class="line">*&#x2F;</span><br><span class="line">namespace Spring;</span><br><span class="line">class Register</span><br><span class="line">&#123;</span><br><span class="line">    protected static $array;</span><br><span class="line">    static function set($key, $value)</span><br><span class="line">    &#123;</span><br><span class="line">        self::$array[$key] &#x3D; $value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    static function get($key)</span><br><span class="line">    &#123;</span><br><span class="line">        return self::$array[$key];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    function _unset($key)</span><br><span class="line">    &#123;</span><br><span class="line">        unset(self::$array[$key]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;注册 数据库全局信息 可以在任何地方使用</span><br><span class="line">Register::set(&#39;database&#39;, $db);</span><br><span class="line">&#x2F;&#x2F;调用</span><br><span class="line">\Spring\Register::get(&#39;database&#39;)</span><br></pre></td></tr></table></figure></li></ul><h5 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h5><ul><li>-可以将截然不同的函数接口封装成统一的API</li><li>如 mysql/mysqli/pdo ,redis/memcache  实现统一接口定义的方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace Spring\Db;</span><br><span class="line"></span><br><span class="line">use \Spring\IDatabase;</span><br><span class="line"></span><br><span class="line">class MySQLi implements IDatabase</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    function connect($host, $user, $pwd, $dbname)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO: Implement connect() method.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function query($sql)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO: Implement query() method.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function close()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO: Implement close() method.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace Spring\Db;</span><br><span class="line">use \Spring\IDatabase;</span><br><span class="line"></span><br><span class="line">class MySQL implements IDatabase</span><br><span class="line">&#123;</span><br><span class="line">    function connect($host, $user, $pwd, $dbname)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO: Implement connect() method.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function query($sql)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO: Implement query() method.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function close()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO: Implement close() method.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;调用</span><br><span class="line">(new \Spring\Db\MySQL())-&gt;connect(&#39;127.0.0.1&#39;,&#39;root&#39;,&#39;root&#39;,&#39;test&#39;);</span><br></pre></td></tr></table></figure></li></ul><h5 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h5><ul><li>面向对象经常用到的，可以实现解耦</li><li>-将一组特定的行为和算法封装成类，以适应某些特定的上下文环境，</li><li>如 ：一个电商网站系统，针对男性女性用户跳转到不同的商品分类，展示不同的广告 ，如果新增 一种 类型，不用写很多的if else ，互不影响  只需增加一种策略即可，实现接口，依赖关系实现反转（面向对象经常用到的，可以实现解耦）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 传统模式</span><br><span class="line">if (isset($_GET[&#39;female&#39;])) &#123;</span><br><span class="line">    $feMaleUserStrategy &#x3D; new \Spring\FeMaleUserStrategy();</span><br><span class="line">    $feMaleUserStrategy-&gt;showAd();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    $maleUserStrategy &#x3D; new \Spring\MaleUserStrategy();</span><br><span class="line">    $maleUserStrategy-&gt;showAd();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 策略模式</span><br><span class="line">interface UserStrategy</span><br><span class="line">&#123;</span><br><span class="line">  function showAd();</span><br><span class="line">&#125;</span><br><span class="line">class MaleStrategy implements UserStrategy&#123;</span><br><span class="line">    function  showAd()&#123;</span><br><span class="line">        echo &#39;男人&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class FeMaleStrategy implements UserStrategy&#123;</span><br><span class="line">    function showAd()&#123;</span><br><span class="line">        echo &#39;女人&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class IndexController</span><br><span class="line">&#123;</span><br><span class="line">    protected $strategy;</span><br><span class="line"></span><br><span class="line">    function index()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;strategy-&gt;showAd();</span><br><span class="line">    &#125;</span><br><span class="line">    function setStrategy(\Spring\UserStrategy $strategy)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;strategy &#x3D; $strategy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$index &#x3D; new  IndexController();</span><br><span class="line">if (isset($_GET[&#39;female&#39;])) &#123;</span><br><span class="line">    $strategy &#x3D; new \Spring\FeMaleUserStrategy();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    $strategy &#x3D; new \Spring\MaleUserStrategy();</span><br><span class="line">&#125;</span><br><span class="line">$index-&gt;setStrategy($strategy);</span><br><span class="line">$index-&gt;index();</span><br></pre></td></tr></table></figure></li></ul><h5 id="数据对象映射模式"><a href="#数据对象映射模式" class="headerlink" title="数据对象映射模式"></a>数据对象映射模式</h5><ul><li>将对象和数据存储映射起来，对一个对象的操作会银蛇为对数据存储的操作</li><li>例：实现ORM类，将复杂的SQL语句映射成对象的属性操作</li><li>结合 工厂模式，注册树模式以及数据对象映射模式（可以屏蔽数据库底层调用）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;运用 工厂模式 注册树模式 和 数据对象映射模式</span><br><span class="line">public function test1()&#123;</span><br><span class="line">    &#x2F;&#x2F;不通过 new 方式 创建 user 对象 ，而是通过 工厂模式， 静态调用 createUser ，user 对象通过注册树模式 注册 ，防止重复实列化</span><br><span class="line">    $user &#x3D;  \Spring\Factory::createUser(2);</span><br><span class="line">    $user-&gt;name &#x3D; 1;</span><br><span class="line">    $this-&gt;test2();</span><br><span class="line">    var_dump($user);</span><br><span class="line">&#125;</span><br><span class="line">public function test2()&#123;</span><br><span class="line">    $user &#x3D;   \Spring\Factory::createUser(1);</span><br><span class="line">    $user-&gt;name &#x3D; 2;</span><br><span class="line">    var_dump($user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h5><ul><li>当一个对象状态发生变化时，他的对象会全部收到通知，并自动更新</li><li>例子：一个事件发生后一连串更新操作，传统的方式就是在代码 加逻辑，逻辑增多 难以维护，这种方式是耦合的，增加新的逻辑需要修改事件主体的代码 ，</li><li>它实现了低耦合，非侵入式的通知与更新机制</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;基础事件</span><br><span class="line">class Event extends \Spring\EventGenerator&#123;</span><br><span class="line">    &#x2F;&#x2F;传统，模式</span><br><span class="line">    function trigger1()&#123;</span><br><span class="line">        echo &quot;逻辑1&quot;;</span><br><span class="line">        echo &quot;逻辑2&quot;;</span><br><span class="line">        echo &quot;逻辑3&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;观察者模式</span><br><span class="line">    function trigger2()&#123;</span><br><span class="line">        &#x2F;&#x2F;通知所有的观察者</span><br><span class="line">        $this-&gt;notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$event &#x3D; new Event();</span><br><span class="line">&#x2F;&#x2F;观察者1</span><br><span class="line">class  Observer1 implements \Spring\Observer&#123;</span><br><span class="line">    function update($eventInfo &#x3D; [])</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#39;逻辑1&#39;;</span><br><span class="line">        &#x2F;&#x2F; TODO: Implement deal() method.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;观察者2</span><br><span class="line">class  Observer2 implements \Spring\Observer&#123;</span><br><span class="line">    function update($eventInfo &#x3D; [])</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#39;逻辑2&#39;;</span><br><span class="line">        &#x2F;&#x2F; TODO: Implement deal() method.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;实现 观察者1 处理逻辑1</span><br><span class="line">$event-&gt;addObserver(new Observer1);</span><br><span class="line">&#x2F;&#x2F;实现 观察者2 处理逻辑2</span><br><span class="line">$event-&gt;addObserver(new Observer2);</span><br><span class="line">&#x2F;&#x2F;通知</span><br><span class="line">$event-&gt;trigger1();</span><br><span class="line">$event-&gt;trigger2();</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">&#x2F;&#x2F;观察者模式</span><br><span class="line">namespace Spring;</span><br><span class="line">abstract class EventGenerator</span><br><span class="line">&#123;</span><br><span class="line">    protected $observer &#x3D; [];</span><br><span class="line">    &#x2F;&#x2F;添加观察者</span><br><span class="line">    function addObserver(Observer $observer)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;observer[] &#x3D; $observer;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;通知 其他 观察者</span><br><span class="line">    function notify()</span><br><span class="line">    &#123;</span><br><span class="line">        foreach ($this-&gt;observer as $observer) &#123;</span><br><span class="line">            $observer-&gt;deal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;实现接口 更新逻辑</span><br><span class="line">&lt;?php</span><br><span class="line">namespace Spring;</span><br><span class="line">interface Observer</span><br><span class="line">&#123;</span><br><span class="line">    function deal($eventInfo &#x3D; []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h5><ul><li>与工厂模式作用类似，都是用来创建对象</li><li>与工厂模式实现不同，原型模式是先创建好一个原型对象然后通过clone 原型对象来创建新的对象，这样就避免类创建时重复初始化操作。</li><li>原型模式适用于大对象的创建，创建一个大对象需要很大的开销，如果每次NEW就会消耗很大，原型模式仅仅需要内存拷贝即可</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$prototype &#x3D; new Canvas();</span><br><span class="line">$prototype-&gt;init();</span><br><span class="line"></span><br><span class="line">$canvas1 &#x3D; clone  $prototype;</span><br><span class="line">$canvas2 &#x3D; clone  $prototype;</span><br><span class="line">$canvas1-&gt;dosomething();</span><br><span class="line">$canvas2-&gt;dosomething();</span><br></pre></td></tr></table></figure><h5 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h5><ul><li>可以动态的添加，修改类的功能</li><li>一个类提供了一项功能，如果要在修改并添加额外的功能，传统的编程模式，需要写一个子类来继承他，并重新实现类的方法。</li><li>使用装饰器模式，仅仅需要在运行时添加一个装饰器对象即可实现，可以实现灵活性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">&#x2F;&#x2F;装饰器模式</span><br><span class="line">namespace Spring;</span><br><span class="line"></span><br><span class="line">interface  DrawDecorator</span><br><span class="line">&#123;</span><br><span class="line">    function beforeDraw();</span><br><span class="line">    function afterDraw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Canvas</span><br><span class="line">&#123;</span><br><span class="line">    protected $decorators &#x3D; [];</span><br><span class="line">    &#x2F;&#x2F;添加装饰器</span><br><span class="line">    function addDecorator(DrawDecorator $drawDecorator)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;decorators[] &#x3D; $drawDecorator;</span><br><span class="line">    &#125;</span><br><span class="line">    function beforeDraw()</span><br><span class="line">    &#123;</span><br><span class="line">        foreach ($this-&gt;decorators as $decorator) &#123;</span><br><span class="line">            $decorator-&gt;beforeDraw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function afterDraw()</span><br><span class="line">    &#123;</span><br><span class="line">       &#x2F;&#x2F;控制反转不然，顺序不对</span><br><span class="line">        $decorators &#x3D; array_reverse($this-&gt;decorators);</span><br><span class="line">        foreach ($decorators as $decorator) &#123;</span><br><span class="line">            $decorator-&gt;afterDraw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function draw()</span><br><span class="line">    &#123;   </span><br><span class="line">        $this-&gt;beforeDraw();  </span><br><span class="line">        echo &#39;画画&#39; . &quot;&quot;;</span><br><span class="line">        $this-&gt;afterDraw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ColorDecorator implements \Spring\DrawDecorator &#123;</span><br><span class="line">    function beforeDraw()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO: Implement beforeDraw() method.</span><br><span class="line">        echo &#39;beforeDrawColor&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    function afterDraw()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#39;afterDrawColor&#39;;</span><br><span class="line">        &#x2F;&#x2F; TODO: Implement afterDraw() method.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class SizeDecorator implements \Spring\DrawDecorator &#123;</span><br><span class="line">    function beforeDraw()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#39;beforeDrawsize&#39;;</span><br><span class="line">        &#x2F;&#x2F; TODO: Implement beforeDraw() method.</span><br><span class="line">    &#125;</span><br><span class="line">    function afterDraw()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#39;afterDrawsize&#39;;</span><br><span class="line">        &#x2F;&#x2F; TODO: Implement afterDraw() method.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$canvas &#x3D; new \Spring\Canvas();</span><br><span class="line">$canvas-&gt;addDecorator(new ColorDecorator);</span><br><span class="line">$canvas-&gt;addDecorator(new SizeDecorator);</span><br><span class="line">$canvas-&gt;draw();</span><br></pre></td></tr></table></figure><h5 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h5><ul><li>在不需要了解内部实现的前提下遍历一个聚合对象的内部元素。</li><li>相比传统的编程模式，它可以隐藏遍历元素所需的操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace Spring;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AllUser implements \Iterator</span><br><span class="line">&#123;</span><br><span class="line">    protected $ids;</span><br><span class="line">    protected $data &#x3D; array();</span><br><span class="line">    protected $index;</span><br><span class="line">    function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        $db &#x3D; Factory::createDatabase();</span><br><span class="line">        $result &#x3D; $db-&gt;query(&quot;select id from user&quot;);</span><br><span class="line">        $this-&gt;ids &#x3D; $result-&gt;fetch_all(MYSQLI_ASSOC);</span><br><span class="line">    &#125;</span><br><span class="line">    function current()</span><br><span class="line">    &#123;</span><br><span class="line">        $id &#x3D; $this-&gt;ids[$this-&gt;index][&#39;id&#39;];</span><br><span class="line">        return Factory::getUser($id);</span><br><span class="line">    &#125;</span><br><span class="line">    function next()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;index ++;</span><br><span class="line">    &#125;</span><br><span class="line">    function valid()</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;index &lt; count($this-&gt;ids);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function rewind()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;index &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function key()</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h5><ul><li>在客户端与实体置渐建立一个代理对象proxy 客户端对实体进行操作全部委派给代理对象，隐藏实体的具体实现细节</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace Spring;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Proxy implements IUserProxy</span><br><span class="line">&#123;</span><br><span class="line">    function getUserName($id)</span><br><span class="line">    &#123;</span><br><span class="line">        $db &#x3D; Factory::getDatabase(&#39;slave&#39;);</span><br><span class="line">        $db-&gt;query(&quot;select name from user where id &#x3D;$id limit 1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    function setUserName($id, $name)</span><br><span class="line">    &#123;</span><br><span class="line">        $db &#x3D; Factory::getDatabase(&#39;master&#39;);</span><br><span class="line">        $db-&gt;query(&quot;update user set name &#x3D; $name where id &#x3D;$id limit 1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$proxy &#x3D; new Proxy();</span><br><span class="line">$proxy-&gt;getUserName(1);</span><br><span class="line">$proxy-&gt;setUserName(1,1);</span><br></pre></td></tr></table></figure><h5 id="面向对象编程的基本原则"><a href="#面向对象编程的基本原则" class="headerlink" title="面向对象编程的基本原则"></a>面向对象编程的基本原则</h5><ul><li>单一职责：一个类，只需要做好一件事情。</li><li>开放封闭：一个类，应该是可扩展的。而不可修改的</li><li>依赖倒置：一个类，不应该强依赖另一个类。每一个类对于另一个类都是可替换的。</li><li>配置话：尽可能地使用配置，而不是硬编码</li><li>面向接口编程：只需要关心接口，不需要关心实现</li></ul><h5 id="MVC结构"><a href="#MVC结构" class="headerlink" title="MVC结构"></a>MVC结构</h5><p>  模型-试图-控制器，一种C/S或者B/S软件工程的组织方式</p><ul><li>模型（model）：数据和存储的封装</li><li>视图（view）：展示层的封装</li><li>控制器（controller）：逻辑层的封装</li></ul><h5 id="设计模式简单的应用场景"><a href="#设计模式简单的应用场景" class="headerlink" title="设计模式简单的应用场景"></a>设计模式简单的应用场景</h5><ul><li>使用装饰器模式实现权限验证，模板渲染，json串化</li><li>使用观察者模式实现数据更新事件的一系列更新操作</li><li>使用代理模式实现数据库的主从自动切换</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;命名空间&quot;&gt;&lt;a href=&quot;#命名空间&quot; class=&quot;headerlink&quot; title=&quot;命名空间&quot;&gt;&lt;/a&gt;命名空间&lt;/h5&gt;&lt;p&gt;(PHP 5 &amp;gt;= 5.3.0, PHP 7)&lt;br&gt;什么是命名空间？从广义上来说，命名空间是一种封装事物的方法。在很
      
    
    </summary>
    
    
      <category term="PHP" scheme="http://jas-wang.fun/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://jas-wang.fun/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://jas-wang.fun/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>PHP性能优化点</title>
    <link href="http://jas-wang.fun/2020/05/14/php/"/>
    <id>http://jas-wang.fun/2020/05/14/php/</id>
    <published>2020-05-14T01:52:46.000Z</published>
    <updated>2020-07-21T09:57:38.946Z</updated>
    
    <content type="html"><![CDATA[<p>摘要<br>对线上站点做压力测试的时候，我们一定要将请求数和并发数，特别是并发数要设置的比较低，我们不能对线上的网站造成压力问题，不管是自己的还是别人的。<br>PHP性能问题一般不会超过占整个项目性能的50%，一般在30%~40%。</p><hr><h4 id="PHP-性能问题的解决方向"><a href="#PHP-性能问题的解决方向" class="headerlink" title="PHP 性能问题的解决方向"></a>PHP 性能问题的解决方向</h4><h4 id="一、语言级性能优化"><a href="#一、语言级性能优化" class="headerlink" title="一、语言级性能优化"></a>一、语言级性能优化</h4><ul><li>指的是PHP语法基本功能，这部分优化比较简单易见、快速可行，比较快速看到效果</li></ul><h5 id="1-压力测试工具-Apache-Benchmark-ab"><a href="#1-压力测试工具-Apache-Benchmark-ab" class="headerlink" title="1.压力测试工具 Apache Benchmark (ab)"></a>1.压力测试工具 Apache Benchmark (ab)</h5><ul><li>ab 是由 Apache 提供的压力测试软件，安装 apache 服务器时会自带该压力测试软件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./ab -n1000 -c100 http://www.baidu.com/</span><br><span class="line">-n ：总共的请求执行数，缺省是1；</span><br><span class="line">-c： 并发数，缺省是1；</span><br><span class="line">-t：测试所进行的总时间，秒为单位，缺省50000s</span><br><span class="line">-p：POST时的数据文件</span><br><span class="line">-w: 以HTML表的格式输出结果</span><br></pre></td></tr></table></figure></li><li>参考项<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Failed requests:        0 &#x2F;&#x2F;失败的请求数量。因网络原因或服务器性能原因，发起的请求并不一定全部成功，通过该数值和Complete requests相除可以计算请求的失败率，作为测试结果的重要参考。</span><br><span class="line">Total transferred:      103314 bytes&#x2F;&#x2F;总共传输的数据量，指的是ab从被测服务器接收到的总数据量，包括index.html的文本内容和请求头信息。</span><br><span class="line">HTML transferred:       22700 bytes &#x2F;&#x2F;从服务器接收到的index.html文件的总大小，等于Document Length＊Complete requests＝227 bytes＊100＝22700 bytes</span><br><span class="line">Requests per second:    91.50 [#&#x2F;sec] (mean) &#x2F;&#x2F;平均(mean)每秒完成的请求数：QPS，这是一个平均值，等于Complete requests&#x2F;Time taken for tests&#x3D;100&#x2F;1.093&#x3D;91.50</span><br><span class="line">Time per request:       109.287 [ms] (mean) &#x2F;&#x2F;从用户角度看，完成一个请求所需要的时间（因用户数量不止一个，服务器完成10个请求，平均每个用户才接收到一个完整的返回，所以该值是下一项数值的10倍。）</span><br><span class="line">Time per request:       10.929 [ms] (mean, across all concurrent requests)&#x2F;&#x2F; 服务器完成一个请求的时间。</span><br><span class="line">Transfer rate:          92.32 [Kbytes&#x2F;sec] received&#x2F;&#x2F;网络传输速度。对于大文件的请求测试，这个值很容易成为系统瓶颈所在。要确定该值是不是瓶颈，需要了解客户端和被测服务器之间的网络情况，包括网络带宽和网卡速度等信息。</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-PHP-自身能力"><a href="#2-PHP-自身能力" class="headerlink" title="2.PHP 自身能力"></a>2.PHP 自身能力</h5><p>少写代码，多用 PHP 自身能力</p><ul><li>自身代码冗余较多，可读性不佳，并且性能低。为什么性能低：PHP 代码需要编译解释为底层语言，这一过程每次请求都会处理一遍，开销大。多使用 PHP 内置变量、常量、函数。</li></ul><p>PHP 代码运行流程</p><ul><li>php文件 -&gt; zend引擎 -&gt; [Parser] -&gt; Opcodes(要被执行的代码,目前很多 php 的缓存服务使用的都是 opcode，节省了扫描和解析的过程，提升速度。) -&gt; [Exec] =&gt; Output </li></ul><p>PHP 内置函数之间的性能测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array_key_exists() 和 isset()</span><br><span class="line">php 执行效率上： isset &gt; array_key_exists</span><br></pre></td></tr></table></figure><ul><li>当数组个数为10时，两者差异就体现出来了，isset 速度要快近10倍，但不是很明显，而且对于变量是否存在，两者之间的差异没有太大，当变量存在时运行更快，但是这种趋势在是非常微弱的。</li><li>使用 array_key_exists 随着循环的次数增加，程序运行的时间增加量是成几何级数增加的，当一个数组元素个数超过1000时运行速度就非常慢了。</li><li>由于 isset 属于 php 中的语言结构，而 array_key_exists 是函数，所以 isset 更快。</li></ul><h5 id="3-减少-PHP-魔法函数的使用"><a href="#3-减少-PHP-魔法函数的使用" class="headerlink" title="3.减少 PHP 魔法函数的使用"></a>3.减少 PHP 魔法函数的使用</h5><p>PHP自身提供的魔法函数，性能并不是很好 ,是为了给 PHP 程序员省事，PHP 语言为你做了很多，所以尽量减少魔法函数的使用。</p><h5 id="4-Linux-time命令-可以查看PHP文件的执行耗时"><a href="#4-Linux-time命令-可以查看PHP文件的执行耗时" class="headerlink" title="4.Linux time命令-可以查看PHP文件的执行耗时"></a>4.Linux time命令-可以查看PHP文件的执行耗时</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost wwwroot]# time php index.php</span><br><span class="line">real0m0.070s</span><br><span class="line">user0m0.050s (关注这个)</span><br><span class="line">sys0m0.020s</span><br></pre></td></tr></table></figure><p>在上面运行的结果中，我们只关注user的那一行时间，关于这三个时间的解释，可以参考下面的解释：</p><ul><li>real 时间是指挂钟时间，也就是命令开始执行到结束的时间。这个短时间包括其他进程所占用的时间片，和进程被阻塞时所花费的时间。</li><li>user 时间是指进程花费在用户模式中的CPU时间，这是唯一真正用于执行进程所花费的时间，其他进程和花费阻塞状态中的时间没有计算在内。</li><li>sys  时间是指花费在内核模式中的CPU时间，代表在内核中执系统调用所花费的时间，这也是真正由进程使用的CPU时间。</li></ul><h5 id="5-错误抑制符"><a href="#5-错误抑制符" class="headerlink" title="5.错误抑制符 @"></a>5.错误抑制符 @</h5><p>@的实际逻辑：在代码开始前、结束后，增加 Opcode，忽略报错<br>性能测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;at.php</span><br><span class="line">file_get_contens(&#39;xxx&#39;); &#x2F;&#x2F; 直接获取一个不存在文件的内容，此时会报错</span><br><span class="line"></span><br><span class="line">方便查看执行过程我们可以使用 vld 扩展执行at.php，查看执行过程的完整 Opcode</span><br><span class="line">php -dvld.active&#x3D;1 -dvld.execute&#x3D;0 at.php</span><br><span class="line"># 不加@错误抑制符时Opcode的执行情况</span><br><span class="line">SEND_VAL</span><br><span class="line">DO_FCALL</span><br><span class="line">RETURN</span><br><span class="line"># 加@错误抑制符时Opcode的执行情况</span><br><span class="line">BEGIN_SILENCE</span><br><span class="line">SEND_VAL</span><br><span class="line">DO_FCALL</span><br><span class="line">END_SILENCE</span><br><span class="line">RETURN</span><br></pre></td></tr></table></figure><p>建议：可以使用 try throw 方式进行错误控制</p><h5 id="6-合理使用内存"><a href="#6-合理使用内存" class="headerlink" title="6.合理使用内存"></a>6.合理使用内存</h5><p>PHP 有内存回收机制保底，但也要小心使用内存 利用 unset()及时释放不使用的内存</p><h5 id="7-避免在循环内做运算"><a href="#7-避免在循环内做运算" class="headerlink" title="7.避免在循环内做运算"></a>7.避免在循环内做运算</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">优化前</span><br><span class="line">$str &#x3D; &quot;hello world&quot;;</span><br><span class="line">for ($i&#x3D;0; $i &lt; strlen($str); $i++) &#123;</span><br><span class="line">    # code...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 其中strlen()方法会在每次循环时计算一次</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 进行优化</span><br><span class="line">$str &#x3D; &quot;hello world&quot;;</span><br><span class="line">$strlen &#x3D; strlen($str);</span><br><span class="line">for ($i&#x3D;0; $i &lt; $strlen; $i++) &#123;</span><br><span class="line">    # code...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="8-务必适用带引号字符串做键值"><a href="#8-务必适用带引号字符串做键值" class="headerlink" title="8.务必适用带引号字符串做键值"></a>8.务必适用带引号字符串做键值</h5><p>PHP 会将没有引号的键值当做常量，产生查找常量的开销</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define(&#39;key&#39;, &#39;test&#39;);</span><br><span class="line"></span><br><span class="line">$array &#x3D; array(</span><br><span class="line">    &#39;key&#39; &#x3D;&gt; &#39;1&#39;,</span><br><span class="line">    &#39;test&#39; &#x3D;&gt; &#39;2&#39;</span><br><span class="line">);</span><br><span class="line">echo $array[&quot;key&quot;] . &#39;\n&#39;; &#x2F;&#x2F; 输出 1</span><br><span class="line">echo $array[key] . &#39;\n&#39;; &#x2F;&#x2F; 输出 2</span><br></pre></td></tr></table></figure><p>当时用$array[key]时，程序也把 key 作为常量去查找，当查找到时，获取到常量的值；当没查找到时，再到数组内部，将其作为键 key 字符串进行解析</p><h4 id="二、PHP-周边环境影响"><a href="#二、PHP-周边环境影响" class="headerlink" title="二、PHP 周边环境影响"></a>二、PHP 周边环境影响</h4><h5 id="1-运行环境"><a href="#1-运行环境" class="headerlink" title="1.运行环境"></a>1.运行环境</h5><ul><li>Linux运行环境</li><li>文件存储 （读写磁盘，数据库，内存，网络数据）</li><li>数据库</li><li>缓存 【内存，PHP缓存技术，redis】</li><li>网络</li></ul><p>优化方向</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-读写内存 &lt;&lt;(远小于) 读写数据库[基于文件系统，操作本地磁盘] &lt;(小于) 读写磁盘 &lt; 读写网络数据</span><br><span class="line"></span><br><span class="line">-数据库会使用内存作为缓存，将其热数据先缓存在内存中，异步地写入到数据库 &#x3D;&gt; 数据库介于内存和磁盘之间</span><br><span class="line"></span><br><span class="line">-网络数据：通过socket发起，socket使用的是本地的文件句柄，磁盘操作。受网络延迟影响， 延迟大时远远</span><br><span class="line">小于读写磁盘，延迟小时和读写磁盘差不多。</span><br></pre></td></tr></table></figure><p>建议：尽可能多的使用读写数据库、读写内存，尽量规避操作磁盘和操作网络数据。</p><h5 id="2-优化网络请求"><a href="#2-优化网络请求" class="headerlink" title="2.优化网络请求"></a>2.优化网络请求</h5><p>(1).网络请求的坑：对方接口的不确定因素 ,网络的稳定性<br>(2).如何优化网络请求？</p><ul><li>设置超时时间：（连接超时，读超时，写超时）</li><li>将串行请求并行化：使用 curlmulti*() =&gt; 最简单，但是并不是最好用；使用 swoole 扩展 =&gt; 效果更好<br><a href="https://www.cnblogs.com/52fhy/p/8908315.html" target="_blank" rel="noopener">curl_multi实现并发列子</a></li></ul><h5 id="3-开启PHP慢日志查询"><a href="#3-开启PHP慢日志查询" class="headerlink" title="3.开启PHP慢日志查询"></a>3.开启PHP慢日志查询</h5><ul><li>找到php-fpm.conf文件</li><li>去掉request_slowlog_timeout前面的分号，并设置时间。如：request_slowlog_timeout=5表示超过5秒的</li><li>慢日志文件位置默认在php的安装目录下的log文件夹中，可以通过修改slowlog = log/$pool.log.slow参数来指定。</li><li>php-fpm慢日志的例子，慢日志会记录下进程号，脚本名称，具体哪个文件哪行代码的哪个函数执行时间过长。</li><li>request_slowlog_timeout 和 slowlog需要同时设置，开启request_slowlog_timeout的同时需要开启 slowlog</li><li>慢日志路径需要手动创建 (slowlog)</li></ul><h5 id="4-借助-xhprof-工具分析-PHP-性能"><a href="#4-借助-xhprof-工具分析-PHP-性能" class="headerlink" title="4.借助 xhprof 工具分析 PHP 性能"></a>4.借助 xhprof 工具分析 PHP 性能</h5><p><a href="/2020/07/20/php-xhprof/">php-性能分析工具-xhprof</a></p><h4 id="三、-PHP-性能瓶颈终极办法"><a href="#三、-PHP-性能瓶颈终极办法" class="headerlink" title="三、 PHP 性能瓶颈终极办法"></a>三、 PHP 性能瓶颈终极办法</h4><h5 id="1-APC-Alternative-PHP-Cache"><a href="#1-APC-Alternative-PHP-Cache" class="headerlink" title="1.APC (Alternative PHP Cache)"></a>1.APC (Alternative PHP Cache)</h5><ul><li>是一款开源的php插件,用来对php的代码或者用户数据进行缓存。</li><li>apc可以去掉php动态解析以及编译的时间，php脚本可以执行的更快。</li><li>PHP是一个动态脚本语言，所以为了让用户在浏览器中看到页面内容，服务器必须解析php代码从而生成想用的html代码。从上面的图中可以看出，在没有apc的时候，用户对php页面的每一次请求，服务器都需要进行对php进行解析，编译以及执行，但是很多时候，只要php代码没有发生更改，php的执行逻辑就不会改变，也就是说解析以及编译的过程就可以省略，直接执行然后将结果返回即可。这就是apc的工作，apc缓存php的可执行代码，从而去掉了解析以及编译的过程，加快了php脚本的执行速度。</li><li>缓存数据量小，大的话建议redis或者memcache</li></ul><p>这里有一个简单的例子对比redis 和 apc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function getTimeStamp() &#123;  </span><br><span class="line">  $timestr &#x3D; microtime();  </span><br><span class="line">  $timestrary &#x3D; explode(&#39; &#39;, $timestr);  </span><br><span class="line">  $result &#x3D; intval($timestrary[1])*1000 + intval(floatval($timestrary[0])*1000);  </span><br><span class="line">  return $result;  </span><br><span class="line">&#125;   </span><br><span class="line">$redis &#x3D; new Redis();  </span><br><span class="line">$redis-&gt;connect(&#39;127.0.0.1&#39;, 6379);  </span><br><span class="line">$key &#x3D; &#39;key&#39;;  </span><br><span class="line">$value &#x3D;&#39;value&#39;;  </span><br><span class="line">$redis-&gt;set($key, $value);  </span><br><span class="line">    </span><br><span class="line">apc_store($key, $value, 1);   </span><br><span class="line">    </span><br><span class="line">$begin &#x3D; getTimeStamp();  </span><br><span class="line">for($i &#x3D; 0 ; $i &lt; 100000 ; $i &#x3D; $i +1) &#123;  </span><br><span class="line">  $result &#x3D; apc_fetch($key);  </span><br><span class="line">&#125;   </span><br><span class="line">$cost &#x3D; getTimeStamp() - $begin;  </span><br><span class="line">var_dump($cost);  </span><br><span class="line">$begin &#x3D; getTimeStamp();  </span><br><span class="line">for($i &#x3D; 0 ; $i &lt; 100000 ; $i &#x3D; $i +1) &#123;  </span><br><span class="line">  $result &#x3D; $redis-&gt;get($key);  </span><br><span class="line">&#125;   </span><br><span class="line">$cost &#x3D; getTimeStamp() - $begin;  </span><br><span class="line">var_dump($cost);  </span><br><span class="line">$redis-&gt;close();</span><br></pre></td></tr></table></figure><p>都是简单的取数据操作，分别进行10万次，单位是毫秒。最后的运行结果redis10万次读在4-5秒之间，而apc得10万次读只有50毫秒左右。可以看到如果是简单的缓存一些数据，并且这些数据不会变化且命中的话，apc还是能带来一定的效率提升的。</p><p>apc php.ini 配置参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extension&#x3D; apc.so   &#x2F;&#x2F;添加扩展</span><br><span class="line">apc.enabled&#x3D;1   &#x2F;&#x2F;开启apc</span><br><span class="line">apc.shm_segments&#x3D;1   </span><br><span class="line">apc.shm_size&#x3D;64M ; apc内存的大小,最后的大小需要乘上segments的数量，所以这里一共为apc分配64M   </span><br><span class="line">apc.ttl&#x3D;7200   </span><br><span class="line">apc.user_ttl&#x3D;7200  </span><br><span class="line">apc.enable_cli&#x3D;1 ; 这个如果不开启，则只可以在网页上进行apc操作，不能通过cli进行apc操作</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要&lt;br&gt;对线上站点做压力测试的时候，我们一定要将请求数和并发数，特别是并发数要设置的比较低，我们不能对线上的网站造成压力问题，不管是自己的还是别人的。&lt;br&gt;PHP性能问题一般不会超过占整个项目性能的50%，一般在30%~40%。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;PH
      
    
    </summary>
    
    
      <category term="PHP" scheme="http://jas-wang.fun/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://jas-wang.fun/tags/PHP/"/>
    
      <category term="性能优化" scheme="http://jas-wang.fun/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>PHP性能分析工具——xhprof</title>
    <link href="http://jas-wang.fun/2020/03/20/php-xhprof/"/>
    <id>http://jas-wang.fun/2020/03/20/php-xhprof/</id>
    <published>2020-03-20T01:52:46.000Z</published>
    <updated>2020-07-21T09:57:48.897Z</updated>
    
    <content type="html"><![CDATA[<p>简介<br>XHProf是一个分层PHP性能分析工具。它报告函数级别的请求次数和各种指标，包括阻塞时间，CPU时间和内存使用情况。<br>Xhprof是facebook开源出来的一个php轻量级的性能分析工具，跟Xdebug类似，但性能开销更低，还可以用在生产环境中，也可以由程序开关来控制是否进行profile。</p><hr><h5 id="什么时候应该进行性能分析？"><a href="#什么时候应该进行性能分析？" class="headerlink" title="什么时候应该进行性能分析？"></a>什么时候应该进行性能分析？</h5><p>在考虑是否进行性能分析时，你首先要想：应用是否存在性能问题？如果有，你要进一步考虑：这个问题有多大？<br>如果你不这样做，将会陷入一个陷阱——过早优化，这可能会浪费你的时间。<br>为了评断应用是否存在性能问题，你应该确定性能目标。例如，100 个并发用户的响应时间小于 1s 。<br>然后，你需要进行基准测试，看是否达到这个目标。一个常见的错误是，在开发环境进行基准测试。事实上，你必须在生产环境进行基准测试。</p><h5 id="XHProf-XHGui"><a href="#XHProf-XHGui" class="headerlink" title="XHProf + XHGui"></a>XHProf + XHGui</h5><p>XHProf 由 Facebook 开发的，包含一个基本的用户界面用于查看性能数据。此外，Paul Reinheimer 开发了 XHGui 和一个增强的用户界面（UI）用于查看、比较和分析性能数据。</p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.pecl 安装</span><br><span class="line">pecl install xhprof 安装完成直接重启php </span><br><span class="line">$ php -m | grep xhprof</span><br><span class="line">xhprof</span><br><span class="line">2.源码安装</span><br><span class="line">wget http:&#x2F;&#x2F;pecl.php.net&#x2F;get&#x2F;xhprof-0.9.4.tgz</span><br><span class="line"></span><br><span class="line">tar -zxvf xhprof-0.9.4.tgz &amp;&amp; cd xhprof-0.9.4.tgz</span><br><span class="line">phpize &amp;&amp; .&#x2F;configure &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>一旦你编译了该扩展程序，您必须启用它。为此，您需要在 php.ini 文件添加以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[xhprof]</span><br><span class="line">extension         &#x3D; xhprof.so  </span><br><span class="line">xhprof.output_dir &#x3D; &#x2F;var&#x2F;www&#x2F;html&#x2F;php-run-tmp&#x2F;  定义输出文件的存放位置</span><br></pre></td></tr></table></figure><p>完成后重启php<br>具体文档可以查看官方文档地址 ：<a href="https://www.php.net/xhprof" target="_blank" rel="noopener">https://www.php.net/xhprof</a></p><p>例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$XHPROF_ROOT &#x3D; realpath(dirname(__FILE__) .&#39;&#x2F;..&#39;);</span><br><span class="line">include_once $XHPROF_ROOT . &quot;&#x2F;xhprof_lib&#x2F;utils&#x2F;xhprof_lib.php&quot;;</span><br><span class="line">include_once $XHPROF_ROOT . &quot;&#x2F;xhprof_lib&#x2F;utils&#x2F;xhprof_runs.php&quot;;</span><br><span class="line">&#x2F;&#x2F;开启xhprof</span><br><span class="line">xhprof_enable(XHPROF_FLAGS_CPU + XHPROF_FLAGS_MEMORY);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注册一个函数，当程序执行结束的时候去执行它。</span><br><span class="line">register_shutdown_function(function() &#123;</span><br><span class="line">    &#x2F;&#x2F;stop profiler</span><br><span class="line">    $xhprof_data &#x3D; xhprof_disable();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;冲刷(flush)所有响应的数据给客户端</span><br><span class="line">    if (function_exists(&#39;fastcgi_finish_request&#39;)) &#123;</span><br><span class="line">        fastcgi_finish_request();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    $xhprof_runs &#x3D; new XHProfRuns_Default();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;save the run under a namespace &quot;xhprof_foo&quot;</span><br><span class="line">    $run_id &#x3D; $xhprof_runs-&gt;save_run($xhprof_data, &quot;xhprof_foo&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行框架 查看 目录下生成了很多文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd  var&#x2F;www&#x2F;html&#x2F;php-run-tmp&#x2F; &amp;&amp; ll </span><br><span class="line">$ 5f1556ce4197a.xhprof.xhprof  </span><br><span class="line">  5f1558bc70a6c.xhprof.xhprof</span><br></pre></td></tr></table></figure><p>配置nginx 站点访问目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">root &#x2F;xhprof&#x2F;xhprof_html;</span><br><span class="line">index  index.html index.php;</span><br><span class="line"></span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        fastcgi_index  index.php;</span><br><span class="line">        fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</span><br><span class="line">        include        fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此结束，浏览器输入localhost 地址访问<br><img src="/images/1.jpg" alt=""></p><h5 id="默认的UI里列出了："><a href="#默认的UI里列出了：" class="headerlink" title="默认的UI里列出了："></a>默认的UI里列出了：</h5><ul><li>funciton name ： 函数名</li><li>calls: 调用次数</li><li>Incl. Wall Time (microsec)： 函数运行时间（包括子函数）</li><li>IWall%：函数运行时间（包括子函数）占比</li><li>Excl. Wall Time(microsec)：函数运行时间（不包括子函数）</li><li>EWall%：函数运行时间（不包括子函数）</li></ul><p>在web中还可以看到 [View Full Callgraph] 链接，<br>点击后可以绘制出一张可视化的性能分析图，如果点击后报错的话，<br>可能是缺少依赖graphviz。graphviz是一个绘制图形的工具，可以更为直观的让你查看性能的瓶颈。如果需要可以安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install graphviz</span><br></pre></td></tr></table></figure><p>就可以看到 绘制的图标！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简介&lt;br&gt;XHProf是一个分层PHP性能分析工具。它报告函数级别的请求次数和各种指标，包括阻塞时间，CPU时间和内存使用情况。&lt;br&gt;Xhprof是facebook开源出来的一个php轻量级的性能分析工具，跟Xdebug类似，但性能开销更低，还可以用在生产环境中，也可以
      
    
    </summary>
    
    
      <category term="PHP" scheme="http://jas-wang.fun/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://jas-wang.fun/tags/PHP/"/>
    
      <category term="工具" scheme="http://jas-wang.fun/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>MySQL性能优化-数据库结构优化</title>
    <link href="http://jas-wang.fun/2019/07/21/mysql-strcut/"/>
    <id>http://jas-wang.fun/2019/07/21/mysql-strcut/</id>
    <published>2019-07-21T02:00:46.000Z</published>
    <updated>2020-07-21T05:42:27.984Z</updated>
    
    <content type="html"><![CDATA[<p>摘要 </p><ul><li>Mysql性能优化就算通过合理安排资源，调整系统参数使MYSQL运行更快，更节省资源。MYSQL性能优化包括查询速度优化，更新速度优化，mysql服务器优化等等。此处，介绍以下几个优化。包含，性能优化的介绍，查询优化，数据库结构优化，mysql服务器优化。</li><li>Mysql优化，一方面是找出系统的瓶颈，提高mysql数据库整体的性能，另外一个方面需要合理的结构设计和参数调整，以提高用户操作响应的速度。同时还要尽可能节省系统资源，以便系统可以提供更大负荷的服务。mysql数据库优化是多方面的，原则是减少系统的瓶颈，减少资源的占用，增加系统反应的速度</li></ul><hr><h5 id="选择合适的数据类型"><a href="#选择合适的数据类型" class="headerlink" title="选择合适的数据类型"></a>选择合适的数据类型</h5><p> 数据类型的选择，重点在于合适二字，如何确定选择的数据类型是否合适？</p><ul><li>使用可以存下你的数据的最小的数据类型</li><li>使用简单的数据类型。int要比varchar类型在mysql处理上简单</li><li>尽可能的使用not null定义字段</li><li>尽可能的少用text类型，非用不可的时候可以考虑分表</li><li>int 类型存储时间戳，可以用 FROM_UNIXTIME(time) 转换</li><li>biginit存储IP地址 INET_ATON() 存储,INET_NTOA()读取</li></ul><h5 id="表的范式化和反范式化"><a href="#表的范式化和反范式化" class="headerlink" title="表的范式化和反范式化"></a>表的范式化和反范式化</h5><ul><li>范式化是指数据库设计的规范，目前说到的范式化一般值第三设计范式，也就是要求数据表中不存在非关键字段对任意候选关键字段的传递函数依赖<br>则符合第三范式存在以下传递函数依赖关系：<br>　　<code>（商品名称）-&gt;（分类）-&gt;（分类描述）</code><br>也就是说存在非关键字段“分类描述”对关键字段”商品名称“的传递函数依赖 会出现异常比如我把删除商品数据最后会把分类信息也会删除调</li><li>反范式化是指为了查询效率的考虑把原本符合第三范式的表适当添加冗余，以达到优化查询效率的目的，反范式是一种一空间换时间的操作</li></ul><h5 id="数据库的拆分过程基本遵循的顺序是：垂直拆分、读写分离、水平拆分-也称之为分库分表-。"><a href="#数据库的拆分过程基本遵循的顺序是：垂直拆分、读写分离、水平拆分-也称之为分库分表-。" class="headerlink" title="数据库的拆分过程基本遵循的顺序是：垂直拆分、读写分离、水平拆分(也称之为分库分表)。"></a>数据库的拆分过程基本遵循的顺序是：垂直拆分、读写分离、水平拆分(也称之为分库分表)。</h5><h5 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h5><h5 id="1、什么是垂直拆分？"><a href="#1、什么是垂直拆分？" class="headerlink" title="1、什么是垂直拆分？"></a>1、什么是垂直拆分？</h5><p>指的是将一个包含了很多表的数据库,根据表的功能的不同,拆分为多个小的数据库,每个库中包含部分表。</p><p>比如：电商系统采用的库为db_eshop,根据用户功能和产品功能,可以拆分为用户库db_user和产品库db_product。<br>所谓垂直拆分，就是把原来一个有多列的表拆分成多个表，这解决了表的宽度问题，通常垂直拆分可以按照下面原则：</p><ul><li>通常把不常用的字段单独存放到一个表中。</li><li>把大字段独立存到一个表中</li><li>把经常使用的字段放到一起</li></ul><h5 id="2、什么时候使用垂直拆分？"><a href="#2、什么时候使用垂直拆分？" class="headerlink" title="2、什么时候使用垂直拆分？"></a>2、什么时候使用垂直拆分？</h5><p>刚开始,可能公司的技术团队规模比较小,所有的数据都存放在一个库中。</p><p>随着公司业务的发展,技术团队人员扩张,划分为不同的技术小组,不同的小组负责不同的业务模块。</p><p>如：A小组负责用户模块,B小组负责产品模块。此时可以将数据库进行垂直拆分。</p><h5 id="3、垂直拆分的好处？"><a href="#3、垂直拆分的好处？" class="headerlink" title="3、垂直拆分的好处？"></a>3、垂直拆分的好处？</h5><ul><li><p>垂直拆分会使得单个用户请求的响应时间变长,但是会使得整个服务的吞吐量大大的增加。（服务吞吐量即系统在单位时间内处理请求的数量）</p></li><li><p>使得单个用户请求的响应时间变长的原因在于：在单体应用场景下,所有的业务都在一个节点内部完成,而垂直拆分后,通常会需要进行rpc调用,<br>rpc的调用会加长单个用户请求的响应时间。</p></li></ul><h5 id="4、垂直拆分的另外2种用途？"><a href="#4、垂直拆分的另外2种用途？" class="headerlink" title="4、垂直拆分的另外2种用途？"></a>4、垂直拆分的另外2种用途？</h5><ul><li><p>将一个包含了很多字段的大表拆分为多个小表,每个表中包含部分字段(基本很少遇到)</p></li><li><p>进行服务化(SOA)的改造,除了业务上需要进行拆分,底层的存储也需要进行隔离</p></li></ul><h5 id="二、读写分离"><a href="#二、读写分离" class="headerlink" title="二、读写分离"></a>二、读写分离</h5><h5 id="1、什么是读写分离？"><a href="#1、什么是读写分离？" class="headerlink" title="1、什么是读写分离？"></a>1、什么是读写分离？</h5><ul><li><p>将数据库分为主库和从库,一个主库用于写数据,多个从库完成读数据的操作。</p></li><li><p>主从库通过某种机制进行数据的同步。</p></li></ul><h5 id="2、为什么需要使用读写分离？"><a href="#2、为什么需要使用读写分离？" class="headerlink" title="2、为什么需要使用读写分离？"></a>2、为什么需要使用读写分离？</h5><p>随着业务的不断发展,用户数量和并发量不断上升,此时如果仅靠单个数据库实例来支撑所有的访问压力,数据库将难以支撑。</p><p>比如：产品库中,包含了几万种产品数据,并且每天新增几十条产品数据,而产品库每天的访问可能有几亿甚至几十亿次,数据库读的压力太大,单台mysql实例扛不住。此时可以将数据库进行读写分离,主库负责数据写的操作,多个从库负责数据读的操作。</p><p>注：说白了,读写分离是为了解决数据库读的操作。</p><h5 id="3、数据库进行了读写分离配置后-开发人员需要做哪些事情？"><a href="#3、数据库进行了读写分离配置后-开发人员需要做哪些事情？" class="headerlink" title="3、数据库进行了读写分离配置后,开发人员需要做哪些事情？"></a>3、数据库进行了读写分离配置后,开发人员需要做哪些事情？</h5><p>DBA将mysql配置成主从复制,开发人员需要做如下事情：</p><ul><li><p>更新数据库数据时,应用将数据写入到master主库</p></li><li><p>主库将数据同步给多个slave从库</p></li><li><p>当查询数据时,应用选择某一个slave节点读取数据。</p></li></ul><h5 id="4、读写分离的优点？"><a href="#4、读写分离的优点？" class="headerlink" title="4、读写分离的优点？"></a>4、读写分离的优点？</h5><p>通过配置多个从库,可以有效的避免过大的访问量对单个库造成的压力。</p><h5 id="5、读写分离技术所面临的问题有哪些？"><a href="#5、读写分离技术所面临的问题有哪些？" class="headerlink" title="5、读写分离技术所面临的问题有哪些？"></a>5、读写分离技术所面临的问题有哪些？</h5><ul><li><p>读写分离的基本操作,是对sql类型进行判断,如果是select等读的请求,就走从库.</p></li><li><p>如果是insert、update、delete等写的请求,就走主库。</p></li></ul><h5 id="主从数据同步延迟的问题"><a href="#主从数据同步延迟的问题" class="headerlink" title="主从数据同步延迟的问题"></a>主从数据同步延迟的问题</h5><p>解决办法：因为数据是从主节点通过网络同步给多个从 节点的,因此必然存在延迟问题。</p><p>因此可能出现如下问题：我们在主节点中插入了数据,但是从节点却读取不到数据的问题。</p><p>对于一些强一致性的业务场景,要求插入数据后必须能读取到,对于这种情况,我们需要提供一种方式,让读的请求也可以走主库,而主库上的数据必然是最新的。</p><h5 id="事务问题"><a href="#事务问题" class="headerlink" title="事务问题"></a>事务问题</h5><p>解决办法： 如果一个事务中同时包含了读的请求和写的请求,如果读的请求走从库,写的请求走主库。由于跨了多个库,那么本地事务已经无法控制。</p><p>而分布式事务非常复杂且效率较低,因此读写分离,目前主流的做法是：将事务中所有sql统一走主库,由于只涉及到一个库,本地事务可以解决。</p><h5 id="综上所述："><a href="#综上所述：" class="headerlink" title="综上所述："></a>综上所述：</h5><ul><li><p>垂直拆分可以解决服务吞吐量即提高系统在单位时间内处理请求的数量</p></li><li><p>读写分离可以缓解单库的压力,增强用户并发访问量</p></li><li><p>即经过垂直拆分和主从同步的数据库完全可以承受住难以想象的高并发访问操作。    </p></li></ul><h5 id="三、水平拆分"><a href="#三、水平拆分" class="headerlink" title="三、水平拆分"></a>三、水平拆分</h5><h5 id="1、什么是水平拆分（分表分库）？"><a href="#1、什么是水平拆分（分表分库）？" class="headerlink" title="1、什么是水平拆分（分表分库）？"></a>1、什么是水平拆分（分表分库）？</h5><p>通过一种算法,将数据库进行分割的架构。每个分片中的数据没有重合,所有分片中的数据并集组成全部数据。</p><p>水平分表实际又可以分为如下三种：只分表、只分库、分库分表</p><ul><li><p>只分表：将db库中的user表拆分为2个分表,即uer_0和user_1</p></li><li><p>只分库：将db库拆分为db_0和db_1这2个库,同时在db_0和db_1库中各自新建一个user表,db_0.user表和db_1.user表中各自只存放原来的db.user表中的部分数据</p></li><li><p>分库分表：将db库拆分为db_0和db_1这2个库,db_0中包含user_0、user_1这2个分表,db_1中包含user_2、user_3这2个分表。</p></li></ul><h5 id="2、为什么需要进行分表分库？"><a href="#2、为什么需要进行分表分库？" class="headerlink" title="2、为什么需要进行分表分库？"></a>2、为什么需要进行分表分库？</h5><p>一旦业务表中的数据量比较大,从维护和性能的角度来看,仍然无法掩盖因为数据量过大从而导致数据库性能下降的事实。因此,这个时候mysql DBA就该对数据库进行水平分区,经过水平分区设置后的业务表,必然能够将原本一张表维护的海量数据分配给N个子表进行存储和维护。</p><p>即：单库容量最容易成为性能瓶颈,当单库容量成为瓶颈,我们希望提高数据库的写的性能,降低单库容量的话,就可以使用水平切分。</p><h5 id="3、分表分库的使用场景？"><a href="#3、分表分库的使用场景？" class="headerlink" title="3、分表分库的使用场景？"></a>3、分表分库的使用场景？</h5><p>如果库中的多个表中只有某张表或者少量表数据量过大,那么只需要针对这些表进行拆分,其它表保持不变。</p><h5 id="4、分库分表的好处？"><a href="#4、分库分表的好处？" class="headerlink" title="4、分库分表的好处？"></a>4、分库分表的好处？</h5><p>如果说读写分离实现数据库读能力的水平提升</p><p>那么,分库分表是是吸纳数据库写能力的水平提升</p><ul><li>存储能力的水平扩展</li></ul><p>在读写分离的情况下,每个集群中的主从库基本上数据时完全一致的,从存储能力上讲<br>在存储海量数据的情况下,可能由于磁盘空间的限制,无法存储所有的数据。<br>而分库分表的情况下,我们可以搭建多个mysql主从复制集群,每个集群只存储部分分片的额数据,实现了存储能力的水平扩展。</p><ul><li>写能力的水平扩展</li></ul><p>在读写分离的情况下,由于每个集群只有一个master,所有的写操作的压力都集中在这一个节点上,在写入并发非常高的情况下,这将会成为整个系统的瓶颈。<br>而在分表分库的情况下,每个分片所属的集群都有一个master节点,都可以执行写入的操作,实现写能力的水平扩展,此外减小建立索引开销,降低写操作的锁操作耗时等,都会带来很多显著的好处。</p><h5 id="5、分库分表的问题"><a href="#5、分库分表的问题" class="headerlink" title="5、分库分表的问题"></a>5、分库分表的问题</h5><p>主要体现在如下4个方面：基本数据的增删改功能、分布式id、分布式事务、动态扩容</p><ul><li>基本的数据库增删改功能</li></ul><p>对于开发人员而言,虽然分库分表的,但是其还是希望能和单库单表那样去操作数据库。</p><p>如：我们要批量插入4条记录,并且希望根据用户的id字段,确定这条记录插入哪个库的那张表中。如：1号记录插入user1表….4号记录插入user4表</p><p>那么之前的单库作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into user(id,name) values (1,”tianshouzhi”),(2,”huhuamin”), (3,”wanghanao”),(4,”luyang”)</span><br></pre></td></tr></table></figure><p>这显然无法实现,因为我们已经对库和表进行了拆分,这种sql语法只能操作mysql的单个库和单个表,所以必须将sql改为4条,然后分表到每个库上去执行,如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">insert into user0(id,name) values  (4,”luyang”)</span><br><span class="line"></span><br><span class="line">insert into user1(id,name) values (1,”tianshouzhi”)</span><br><span class="line"></span><br><span class="line">insert into user2(id,name) values (2,”huhuamin”)</span><br><span class="line"></span><br><span class="line">insert into user3(id,name) values (3,”wanghanao”)</span><br></pre></td></tr></table></figure><h5 id="分布式id"><a href="#分布式id" class="headerlink" title="分布式id"></a>分布式id</h5><ul><li><p>在分库分表后,我们不能再使用mysql的自增主键。</p></li><li><p>因为在插入记录的时候,不同的库生成的记录的自增id可能会出现冲突</p></li><li><p>因此,需要一个全局的id生成器,目前分布式id有很多种方案,其中一个比较轻量级的方案是twitter的snowflake算法。</p></li></ul><h5 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h5><p>分布式事务是分库分表的绕不过去的一个坎,因为涉及到了同时更新多个分片数据。</p><p>如：批量插入记录到四个不同的库,如何保证要么同时成功,要么同时失败。</p><p>关于分布式事务,mysql支持XA事务,但是效率较低。</p><p>柔性事务是目前比较主流的方案,柔性事务包括：最大努力通知型、可靠消息最终一致性方案以及TCC两个阶段提交。</p><p>但是无论XA事务还是柔性事务,实现起来都是非常复杂的。</p><h5 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a>动态扩容</h5><p>动态扩容是指只增加分库分表的数量</p><p>如：将原来user表拆分到2个库的四张表上。</p><p>现在我们希望将分库的数量变为4个,分表的数量变为8个。</p><p>这种情况一般要伴随着数据迁移,如在4张表的情况下,id为7的记录,7%4=3</p><p>因此这条记录位于user3这张表上,但是现在分表的数量变为8个,而7%8=0</p><p>而user0这张表根本没有id=7这条记录,因此如果不进行数据迁移的话,就会出现记录找不到的情况。</p><h5 id="问题：分库分表之后如何实现联合查询？"><a href="#问题：分库分表之后如何实现联合查询？" class="headerlink" title="问题：分库分表之后如何实现联合查询？"></a>问题：分库分表之后如何实现联合查询？</h5><p>可以使用第三方中间件来实现，比如：mycat、shading-jdbc<br>原理解析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当客户端发送一条sql查询：select * from user;此时中间件会根据有几个子表，拆分成多个语句：</span><br><span class="line">select * from user1;select * from user2;select * from user3等多条语句查询，</span><br><span class="line">然后将查询的结果返回给中间件，然后汇总给客户端。这些语句是并发执行的，所以效率会很高哦。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Mysql性能优化就算通过合理安排资源，调整系统参数使MYSQL运行更快，更节省资源。MYSQL性能优化包括查询速度优化，更新速度优化，mysql服务器优化等等。此处，介绍以下几个优化。包含，性能优化的介绍，查询优化，数据库结构优化，mys
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://jas-wang.fun/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://jas-wang.fun/tags/MySQL/"/>
    
      <category term="性能优化" scheme="http://jas-wang.fun/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="数据库结构优化" scheme="http://jas-wang.fun/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MySQL性能优化-索引优化</title>
    <link href="http://jas-wang.fun/2018/08/21/mysql-index/"/>
    <id>http://jas-wang.fun/2018/08/21/mysql-index/</id>
    <published>2018-08-21T01:00:46.000Z</published>
    <updated>2020-07-21T05:42:58.303Z</updated>
    
    <content type="html"><![CDATA[<p>摘要 </p><ul><li>Mysql性能优化就算通过合理安排资源，调整系统参数使MYSQL运行更快，更节省资源。MYSQL性能优化包括查询速度优化，更新速度优化，mysql服务器优化等等。此处，介绍以下几个优化。包含，性能优化的介绍，查询优化，数据库结构优化，mysql服务器优化。</li><li>Mysql优化，一方面是找出系统的瓶颈，提高mysql数据库整体的性能，另外一个方面需要合理的结构设计和参数调整，以提高用户操作响应的速度。同时还要尽可能节省系统资源，以便系统可以提供更大负荷的服务。mysql数据库优化是多方面的，原则是减少系统的瓶颈，减少资源的占用，增加系统反应的速度。</li></ul><hr><h5 id="SQL以及索引优化"><a href="#SQL以及索引优化" class="headerlink" title="SQL以及索引优化"></a>SQL以及索引优化</h5><ul><li>如何发现有问题的sql？</li><li>使用MYSQL慢查日志对有效率问题的SQL进行监控<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#39;%log%&#39;;</span><br><span class="line">SET  GLOBAL slow_query_log &#x3D; ON;&#x2F;&#x2F;开启慢查询日志</span><br><span class="line">SHOW VARIABLES LIKE &#39;%slow_query_log%&#39;;</span><br><span class="line">SET  GLOBAL log_queries_not_using_indexes&#x3D;On; &#x2F;&#x2F;是否记录索引 默认false</span><br><span class="line">SET  GLOBAL long_query_time &#x3D; 1;&#x2F;&#x2F;长查询</span><br></pre></td></tr></table></figure></li></ul><h5 id="慢查询日志分析工具-mysqldumpslow"><a href="#慢查询日志分析工具-mysqldumpslow" class="headerlink" title="慢查询日志分析工具-mysqldumpslow"></a>慢查询日志分析工具-mysqldumpslow</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow -t 3 &#x2F;home&#x2F;mysql-slow.log</span><br></pre></td></tr></table></figure><h5 id="EXPLAIN简介"><a href="#EXPLAIN简介" class="headerlink" title="EXPLAIN简介"></a>EXPLAIN简介</h5><p> 使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈。 </p><h5 id="通过explain我们可以获得以下信息："><a href="#通过explain我们可以获得以下信息：" class="headerlink" title="通过explain我们可以获得以下信息："></a>通过explain我们可以获得以下信息：</h5><ul><li>表的读取顺序</li><li>数据读取操作的操作类型</li><li>哪些索引可以使用</li><li>哪些索引被实际使用</li><li>表之间的引用</li><li>每张表有多少行被优化器查询</li><li>使用explain查询SQL的执行计划</li></ul><h5 id="如何分析SQL查询explain返回各列的含义"><a href="#如何分析SQL查询explain返回各列的含义" class="headerlink" title="如何分析SQL查询explain返回各列的含义"></a>如何分析SQL查询explain返回各列的含义</h5><ul><li>table:显示这一行的数据是关于哪张表的</li><li>type:这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const:常量查找 （比如id=1），eq_reg（范围查找），ref（连接查询），range（基于索引范围查找 如id&gt;1）,index（索引扫描）all（表扫描）</li><li>possible_keys:显示可能应用在这张表中的索引。如果为空，没有可能 的索引。</li><li>key:实际使用的索引。如果为null，则没有使用索引。</li><li>ken_len：使用的所有长度。在不损失精确性的情况下，长度越短越好(因为mysql每次读取都是以列为单位的，所以索引的数量越大查询效率越慢)</li><li>ref:显示索引的哪一列被使用了，如果可能的话是一个常数</li><li>rows:返回请求的数据的行数</li></ul><h5 id="extra列需要注意返回值"><a href="#extra列需要注意返回值" class="headerlink" title="extra列需要注意返回值"></a>extra列需要注意返回值</h5><ul><li>Using filesort ：看到这个的时候，查询就需要优化了。MYSQL需要进行额外的步骤来发现如何对返回的行排序。他根据连接类型以及存储排序键值和匹配条件的全部行指针来排序全部行</li><li>Using temporary：查询需要优化。这里mysql需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY.,GROUP BY 上</li></ul><h5 id="执行计划各字段详细含义"><a href="#执行计划各字段详细含义" class="headerlink" title="执行计划各字段详细含义"></a>执行计划各字段详细含义</h5><ul><li><p>id<br> id相同，执行顺序由上至下<br> id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行(比如子查询)<br> id相同不同，同时存在  id相同的可以认为是一组，同一组中从上往下执行，所有组中id大的优先执行</p></li><li><p>type所显示的是查询使用了哪种类型，type包含的类型包括如下图所示的几种，从好到差依次是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all</span><br><span class="line">-- system 表只有一行记录（等于系统表），这是const类型的特列，平时不会出现，这个也可以忽略不计</span><br><span class="line">-- const 表示通过索引一次就找到了，const用于比较primary key 或者unique索引。因为只匹配一行数据，所以很快。</span><br><span class="line">如将主键置于where列表中，MySQL就能将该查询转换为一个常量。 </span><br><span class="line">-- eq_ref 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描</span><br><span class="line">-- ref 非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，</span><br><span class="line">然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体。</span><br><span class="line">-- range 只检索给定范围的行，使用一个索引来选择行，key列显示使用了哪个索引，一般就是在你的where语句中出现</span><br><span class="line">between、&lt; 、&gt;、in等的查询，这种范围扫描索引比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引。</span><br><span class="line">-- index   Full Index Scan，Index与All区别为index类型只遍历索引树。这通常比ALL快，因为索引文件通常比数据文件小。</span><br><span class="line">（也就是说虽然all和Index都是读全表，但index是从索引中读取的，而all是从硬盘读取的） </span><br><span class="line">-- all   Full Table Scan 将遍历全表以找到匹配的行</span><br></pre></td></tr></table></figure></li><li><p>possible_keys 和 key<br>possible_keys 显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。<br>key实际使用的索引，如果为NULL，则没有使用索引。（可能原因包括没有建立索引或索引失效） </p></li><li><p>key_len<br>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度，在不损失精确性的情况下，长度越短越好。</p></li><li><p>rows<br>根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数，也就是说，用的越少越好 </p></li><li><p>Extra</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">--  Using filesort</span><br><span class="line">说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为“文件排序”。</span><br><span class="line">--  Using temporary</span><br><span class="line">使用了用临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于排序order by和分组查询group by。 </span><br><span class="line">--  Using index</span><br><span class="line">表示相应的select操作中使用了覆盖索引（Covering Index），避免访问了表的数据行，效率不错。如果同时出现using where，</span><br><span class="line">表明索引被用来执行索引键值的查找；如果没有同时出现using where，表明索引用来读取数据而非执行查找动作。</span><br><span class="line">-- Using join buffer</span><br><span class="line">表明使用了连接缓存,比如说在查询的时候，多表join的次数非常多，那么将配置文件中的缓冲区的join buffer调大一些。</span><br></pre></td></tr></table></figure></li></ul><h5 id="索引不足之处"><a href="#索引不足之处" class="headerlink" title="索引不足之处"></a>索引不足之处</h5><ul><li><p>索引提高了查询的速度，但是降低了INSERT、UPDATE、DELETE的速度，因为在插入、修改、删除数据时，还要同时操作一下索引文件；</p></li><li><p>建立索引未见会占用一定的磁盘空间。</p></li></ul><h5 id="索引简介"><a href="#索引简介" class="headerlink" title="索引简介"></a>索引简介</h5><ul><li>数据库的索引就像一本书的目录，能够加快数据库的查询速度。</li><li>MYSQL索引有四种PRIMARY、INDEX、UNIQUE、FULLTEXT， 其中PRIMARY、INDEX、UNIQUE是一类，FULLTEXT是一类。</li><li>这四种都是单列索引，也就是他们都是作用于单个一列，所以也称单列索引；但是所以一个索引也可以作用于多个列上，称为组合索引或复合索引</li></ul><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>主键索引 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*RIMARY：主键索引。索引列唯一且不能为空；一张表只能有一个主键索引（主键索引通常在建表的时候就指定）</span><br><span class="line">CREATE TABLE T_USER(ID INT NOT NULL,USERNAME VARCHAR(16) NOT NULL,PRIMARY KEY(ID))</span><br><span class="line">*NORMAL：普通。索引列没有任何限制</span><br><span class="line">CREATE TABLE T_USER(ID INT NOT NULL,USERNAME VARCHAR(16) NOT NULL,INDEX USERNAME_INDEX(USERNAME(16))) </span><br><span class="line">* ALTER语句指定</span><br><span class="line">ALTER TABLE T_USER ADD INDEX U_INDEX (USERNAME) &#x2F;&#x2F;给列USERNAME建普通索引 U_INDEX</span><br><span class="line">* 删除索引</span><br><span class="line">DROP INDEX U_INDEX ON t_user &#x2F;&#x2F;删除表t_user中的索引U_INDEX</span><br></pre></td></tr></table></figure><p>唯一索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UNIQUE：唯一索引。索引列的值必须是唯一的，但允许有空；</span><br><span class="line">* 建表时指定</span><br><span class="line">CREATE TABLE t_user(ID INT NOT NULL,USERNAME VARCHAR(16) NOT NULL,UNIQUE U_INDEX(USERNAME)) &#x2F;&#x2F;给列USERNAME添加唯一索引T_USER</span><br><span class="line">* ALTER语句指定</span><br><span class="line">ALTER TABLE t_user ADD UNIQUE u_index(USERNAME) &#x2F;&#x2F;给列T_USER添加唯一索引u_index</span><br><span class="line">* 删除索引</span><br><span class="line">DROP INDEX U_INDEX ON t_user</span><br></pre></td></tr></table></figure><p>全文索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FULLTEXT：全文搜索的索引。FULLTEXT 用于搜索很长一篇文章的时候，效果最好。用在比较短的文本，</span><br><span class="line">如果就一两行字的，普通的 INDEX 也可以。索引的新建和删除和上面一致，这里不再列举...</span><br></pre></td></tr></table></figure><p>组合索引（复合索引）　　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">新建一张表</span><br><span class="line">CREATE TABLE T_USER(ID INT NOT NULL,USERNAME VARCHAR(16) NOT NULL,CITY VARCHAR(10),PHONE VARCHAR(10),PRIMARY KEY(ID) )</span><br><span class="line"></span><br><span class="line">组合索引就是把多个列加入到统一个索引中，如新建的表T_USER，我们给USERNAME+CITY+PHONE创建一个组合索引</span><br><span class="line">ALTER TABLE t_user ADD INDEX name_city_phone(USERNAME,CITY,PHONE) &#x2F;&#x2F;组合普通索引</span><br><span class="line"></span><br><span class="line">ALTER TABLE t_user ADD UNIQUE name_city_phone(USERNAME,CITY,PHONE) &#x2F;&#x2F;组合唯一索引</span><br></pre></td></tr></table></figure><p>这样的组合索引，其实相当于分别建立了（USERANME,CITY,PHONE   USERNAME,CITY   USERNAME,PHONE）三个索引。<br>为什么没有（CITY,PHONE）索引呢？这是因为MYSQL组合查询“最左前缀”的结果。简单的理解就是只从最左边开始组合。<br>并不是查询语句包含这三列就会用到该组合索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">这样的查询语句才会用到创建的组合索引</span><br><span class="line">SELECT * FROM t_user where USERNAME&#x3D;&quot;parry&quot; and CITY&#x3D;&quot;广州&quot; and PHONE&#x3D;&quot;180&quot;</span><br><span class="line">SELECT * FROM t_user where USERNAME&#x3D;&quot;parry&quot; and CITY&#x3D;&quot;广州&quot;</span><br><span class="line">SELECT * FROM t_user where USERNAME&#x3D;&quot;parry&quot; and PHONE&#x3D;&quot;180&quot;</span><br><span class="line"></span><br><span class="line">这样的查询语句是不会用到创建的组合索引　</span><br><span class="line">SELECT * FROM t_user where CITY&#x3D;&quot;广州&quot; and PHONE&#x3D;&quot;180&quot;</span><br><span class="line">SELECT * FROM t_user where CITY&#x3D;&quot;广州&quot;</span><br><span class="line">SELECT * FROM t_user where PHONE&#x3D;&quot;180&quot;</span><br></pre></td></tr></table></figure><h5 id="索引使用注意事项"><a href="#索引使用注意事项" class="headerlink" title="索引使用注意事项"></a>索引使用注意事项</h5><ul><li>只要列中包含NULL值将不会被包含在索引中，组合索引只要有一列含有NULL值，那么这一列对于组合索引就是无效的，<br>所以我们在设计数据库的时候最好不要让字段的默认值为NULL;</li><li>使用短索引</li><li>如果可能应该给索引指定一个长度，例如：一个VARCHAR(255)的列，但真实储存的数据只有20位的话，在创建索引时应指定索引的<br>长度为20，而不是默认不写。如下</li></ul><p><code>ALTER TABLE t_user add INDEX U_INDEX(USERNAME(16)) 优于 ALTER TABLE t_user add INDEX U_INDEX(USERNAME)</code></p><ul><li><p>使用短索引不仅能够提高查询速度，而且能节省磁盘操作以及I/O操作。</p></li><li><p>索引列排序<br>　　　Mysql在查询的时候只会使用一个索引，因此如果where子句已经使用了索引的话，那么order by中的列是不会使用索引的，所以order by尽量不要包含多个列的排序，如果非要多列排序，最好使用组合索引。</p></li><li><p>Like 语句<br>　　一般情况下不是鼓励使用like,如果非使用，那么需要注意 like”%aaa%”不会使用索引；但like“aaa%”会使用索引。</p></li><li><p>不使用 NOT IN和&lt;&gt;操作</p></li><li><p>索引方式 HASH和 BTREE比较</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　HASH :　用于对等比较，如&quot;&#x3D;&quot;和&quot; &lt;&#x3D;&gt;&quot;</span><br><span class="line">　BTREE:　BTREE索引看名字就知道索引以树形结构存储，通常用在像 &quot;&#x3D;，&gt;，&gt;&#x3D;，&lt;，&lt;&#x3D;、BETWEEN、Like&quot;等操作符查询效率较高；</span><br></pre></td></tr></table></figure><p>通过比较发现，我们常用的是BTREE索引方式，当然Mysql默认就是BTREE方式。</p></li></ul><h5 id="COUNT-和-MAX优化"><a href="#COUNT-和-MAX优化" class="headerlink" title="COUNT 和 MAX优化"></a>COUNT 和 MAX优化</h5><ul><li>max   ：select max(update_time) from ps_table ;  会全表扫描，直接 将 update_time 设置索引</li><li>count : count(id)和count(<em>) 可能统计数量有差别 ，count（</em>） 包含null 的数量</li></ul><h5 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h5><p> 通常情况下，需要把子查询优化为join 查询，优化时需要注意一对多关系，要注意重复数据（可以使用 distinct 优化）</p><h5 id="Group-By-优化"><a href="#Group-By-优化" class="headerlink" title="Group By 优化"></a>Group By 优化</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">优化前：</span><br><span class="line">EXPLAIN SELECT a.first_name,a.last_name, COUNT(*) FROM film_actor fa INNER JOIN actor a USING (actor_id)</span><br><span class="line">GROUP BY  fa.actor_id;</span><br><span class="line"></span><br><span class="line">优化后：</span><br><span class="line">EXPLAIN SELECT a.first_name, a.last_name, COUNT(*) FROM  actor a INNER JOIN film_actor fa USING (actor_id)</span><br><span class="line">GROUP BY  a.actor_id;</span><br></pre></td></tr></table></figure><h5 id="LIMIT-查询优化"><a href="#LIMIT-查询优化" class="headerlink" title="LIMIT 查询优化"></a>LIMIT 查询优化</h5><p>   LIMIT常常用于分页处理，时常会伴随order by 从句使用，因此大多时候会使用filesort文件排序的方式，这样会造成大量IO问题</p><ul><li>情况1：由于title 排序字段没有建立索引，所以排序使用了文件排序 造成大量io</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT film_id,description from film ORDER BY title LIMIT 50,5;</span><br></pre></td></tr></table></figure><ul><li>情况2：排序字段加上 film_id 使用了索引，但是当数据量大（分页越到后面）的时候 也会扫描大量数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT film_id,description from film ORDER BY film_id LIMIT 50,5;</span><br></pre></td></tr></table></figure><ul><li>情况3：使用范围 where  （主键必须顺序增长）或者建立一个索引自增的列保持自增</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT film_id,description from film WHERE film_id &gt;  55 AND film_id &lt; 60  ORDER BY film_id LIMIT 1,5;</span><br></pre></td></tr></table></figure><p>优化思路：避免查询过多数据</p><h5 id="如何选择合适的列建立索引"><a href="#如何选择合适的列建立索引" class="headerlink" title="如何选择合适的列建立索引"></a>如何选择合适的列建立索引</h5><ul><li>在where从句，group by 从句 order by 从句，on 从句出现的列</li><li>索引字段越小越好 （数据库中数据存储单位是列为单位的，数据量存储越大 io消耗越高）</li><li>离散度大的列放到联合索引的前面（唯一值越多，可选择性越多）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from  payment  where staff_id &#x3D; 2 and customer_id&#x3D;584;</span><br><span class="line">SELECT  COUNT(DISTINCT customer_id),COUNT(DISTINCT staff_id) from payment;</span><br></pre></td></tr></table></figure></li></ul><h5 id="问：应该建立-index-staff-id-customer-id-还是-index-customer-id-stuff-id-好-？"><a href="#问：应该建立-index-staff-id-customer-id-还是-index-customer-id-stuff-id-好-？" class="headerlink" title="问：应该建立 index(staff_id,customer_id) 还是 index(customer_id,stuff_id) 好 ？"></a>问：应该建立 index(staff_id,customer_id) 还是 index(customer_id,stuff_id) 好 ？</h5><p>答：由于 customer_id 唯一值 越多，可选择性越多 所以放在最前面 customer_id 的离散度更大，所以应该使用 index(customer_id,stuff_id)</p><h5 id="索引优化SQL方法"><a href="#索引优化SQL方法" class="headerlink" title="索引优化SQL方法"></a>索引优化SQL方法</h5><p>查询数据库冗余索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    a.TABLE_SCHEMA, a.INDEX_NAME, b.INDEX_NAME, a.COLUMN_NAME</span><br><span class="line">FROM</span><br><span class="line">    STATISTICS a</span><br><span class="line">JOIN STATISTICS b ON a.TABLE_SCHEMA &#x3D; b.TABLE_SCHEMA</span><br><span class="line">AND a.TABLE_NAME &#x3D; b.TABLE_NAME AND a.SEQ_IN_INDEX &#x3D; b.SEQ_IN_INDEX</span><br><span class="line">AND a.COLUMN_NAME &#x3D; b.COLUMN_NAME</span><br><span class="line">WHERE a.SEQ_IN_INDEX &#x3D; 1 AND a.INDEX_NAME &lt;&gt; b.INDEX_NAME</span><br></pre></td></tr></table></figure><h5 id="索引的维护以及优化–查找重复以及冗余索引"><a href="#索引的维护以及优化–查找重复以及冗余索引" class="headerlink" title="索引的维护以及优化–查找重复以及冗余索引"></a>索引的维护以及优化–查找重复以及冗余索引</h5><p>MYSQL 目前只能通过慢查询日志配合pt-index-usage工具来进行索引使用情况分析两个工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pt-index-usage -uroot -p &#39;123456&#39; -h 127.0.0.1MYS （索引使用频率工具）</span><br><span class="line">pt-duplicate-key-checker -uroot -p &#39;123456&#39; -h 127.0.0.1MYS （索引重复以及冗余索引工具）</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Mysql性能优化就算通过合理安排资源，调整系统参数使MYSQL运行更快，更节省资源。MYSQL性能优化包括查询速度优化，更新速度优化，mysql服务器优化等等。此处，介绍以下几个优化。包含，性能优化的介绍，查询优化，数据库结构优化，mys
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://jas-wang.fun/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://jas-wang.fun/tags/MySQL/"/>
    
      <category term="性能优化" scheme="http://jas-wang.fun/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="索引优化，SQL优化" scheme="http://jas-wang.fun/tags/%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%EF%BC%8CSQL%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>PHP技术学习路线</title>
    <link href="http://jas-wang.fun/2018/01/15/route/"/>
    <id>http://jas-wang.fun/2018/01/15/route/</id>
    <published>2018-01-15T01:52:46.000Z</published>
    <updated>2020-07-21T09:58:47.359Z</updated>
    
    <content type="html"><![CDATA[<h3 id="入门阶段"><a href="#入门阶段" class="headerlink" title="入门阶段"></a>入门阶段</h3><h4 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h4><ul><li><p>掌握基本HTML、JS、CSS语法；熟悉 Bootstrap。<br>验收最低标准：模仿写出jd.com或者vip.com首页第一屏内容。</p></li><li><p>熟悉Linux命令行<br>熟悉常用发行版系统(CentOS、Ubuntu)安装<br>熟悉常用命令行操作，包括文件管理、用户管理、权限管理、防火墙管理等<br>熟悉VIM使用</p></li></ul><p>验收最低标准：掌握lnmp环境搭建。</p><h4 id="PHP基础"><a href="#PHP基础" class="headerlink" title="PHP基础"></a>PHP基础</h4><ul><li>掌握PHP基础语法、文件上传、cookie、Session、JSON。</li><li>掌握MySQL数据库连接：pdo使用。</li><li>掌握redis连接及简单应用。</li><li>掌握命名空间。</li><li>掌握面向对象编程思想。</li></ul><p>参考：<br><a href="https://www.runoob.com/php/php-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/php/php-tutorial.html</a></p><h4 id="学习框架"><a href="#学习框架" class="headerlink" title="学习框架"></a>学习框架</h4><ul><li><p>学会使用ThinkPHP框架。主要是该框架在国内使用普及率太高了。不建议使用Laravel入门，因为该框架使用了较多的语法糖、第三方库，对新手可能有难度。</p></li><li><p>验收最低标准：可以使用ThinkPHP最新版作为入手框架，写出一个简单的博客。页面简单写就行。数据之间使用TP的 display 渲染到页面。</p></li></ul><h4 id="学习写接口"><a href="#学习写接口" class="headerlink" title="学习写接口"></a>学习写接口</h4><ul><li>学会 Charles 抓包，看豆瓣的接口返回的数据。</li><li>学会写接口（GET、POST）的就行。</li><li>学会使用 POSTMAN。</li></ul><p>验收标最低准：把上面的博客项目改成前后端分离的，先写完接口（最好有文档），再在页面里使用ajax调用接口数据。</p><p>至此，你已经入门了。如果需要继续往下，还要学习。</p><h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><h4 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h4><ul><li>使用 composer 安装PHP第三方库</li><li>对于PHP断点调试非常熟悉</li><li>学习常用PHP扩展</li><li>使用 SPL</li><li><a href="https://learnku.com/docs/psr/basic-coding-standard/1605" target="_blank" rel="noopener">掌握 PSR 规范</a></li><li>掌握反射的使用</li><li>掌握设计模式</li><li>熟练使用常用框架。</li><li>了解php和php-fpm的大部分配置选项和含义。</li><li>熟悉HTTP协议。</li><li>熟悉正则表达式。</li></ul><h4 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h4><ul><li>熟悉MYSQL优化的一些技巧，例如MySQL的性能追查，包括slow_log/explain等；对于order by、limit、like等一些坑能避开；能够熟练使用常用的索引；对于表结构创建选用哪种数据类型做到胸有成竹等等。</li><li>熟悉常用的配置，知道如何调优。</li><li>熟练配置主从。</li></ul><h4 id="NOSQL"><a href="#NOSQL" class="headerlink" title="NOSQL"></a>NOSQL</h4><ul><li>掌握Redis使用：对于常用数据结构的经典使用场景非常熟悉；了解Redis的事务、RDB、AOF等机制。</li><li>掌握memcache的使用，知道与redis的区别。</li><li>了解一下MongoDB。</li></ul><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><ul><li>熟悉常用文本命令：例如wc、awk、split、diff、grep、sed等。</li><li>熟悉sort、uniq的使用。</li><li>熟练掌握ps、netstat、top等命令使用。</li><li>熟练使用Supervisor。</li><li>熟悉如何编写shell脚本。</li><li>能够理解Nginx的配置的含义。</li></ul><h3 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h3><h4 id="PHP-1"><a href="#PHP-1" class="headerlink" title="PHP"></a>PHP</h4><ul><li>该阶段PHP已经非常熟悉了，拥有快速开发项目、快速解决BUG的能力。代码遵循psr规范、稳定性很高。</li><li>熟悉消息队列使用，在很多场景合适的选择消息队列进行异步解耦。</li><li>熟悉如何使用 Elasticsearch 代替MYSQL的全文搜索功能。</li><li>熟悉多进程编程。</li><li>熟悉socket编程，对于网络IO模型有一定的认知，熟悉多路复用(select/poll/epoll)技术。</li><li>熟悉swoole框架，能应用于项目上。</li><li>不限制于框架本身，任何框架一天内快速入手。</li><li>对php的工作机制熟悉，熟悉php-fpm生命周期。</li><li>能够知道PHP相对于c等强类型语言性能为什么会慢。</li><li>对于PHP内部的实现原理有一定的认知，例如变量的实现、zend引擎的了解。</li><li>对于PHP的扩展有一定的认知，可以编写简单的扩展。</li></ul><h4 id="MYSQL-1"><a href="#MYSQL-1" class="headerlink" title="MYSQL"></a>MYSQL</h4><ul><li>熟悉大批量的数据导入导出。对于线上大表操作可能带来的风险有预知。</li><li>熟悉分库分表。</li><li>对主从延迟能有效解决。</li><li>对于MySQL内置的一些函数能够熟练使用，熟悉触发器、存储过程的使用。</li><li>熟悉服务器核心性能优化选项 innodb_log_buffer_size、back_log、table_open_cache、thread_cache_size、innodb_lock_wait_timeout等。</li><li>对于MySQL内部索引的实现、事务隔离机制有一定的认知。</li></ul><h4 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h4><ul><li>redis常用5中数据类型之外的数据结构也要能掌握一些。如bitmap、GEO、HyperLogLog、pub/sub等。</li><li>redis里的事务、管道、分布式锁能熟练使用。</li><li>对于redis的服务端结构能有一定认知。</li><li>熟悉redis里如何使用Lua。</li><li>尝试阅读redis源码。</li></ul><h4 id="Linux-1"><a href="#Linux-1" class="headerlink" title="Linux"></a>Linux</h4><ul><li>对于nginx非常熟悉，能够熟练配置https、负载均衡、反向代理；能够使用 lua-nginx-module。</li><li>对awk/sed 等应用已经如火纯青，能够随意操作控制处理文本统计分析各种复杂格式的数据。</li><li>对于tcpdump、gdb、ltrace、strace、lsof等熟练使用。</li></ul><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><ul><li>熟悉Linux应用编程：熟悉makefile使用；熟悉进程、信号、I/O知识；对于C语言有一定的了解。</li><li>熟练elk。</li><li>对于其它语言(例如java、c、golang）、其它领域(大数据)有一定的认知。</li><li>熟悉RPC、微服务架构。</li><li>能够支持对于千万级流量网站的正常开发维护工作。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;入门阶段&quot;&gt;&lt;a href=&quot;#入门阶段&quot; class=&quot;headerlink&quot; title=&quot;入门阶段&quot;&gt;&lt;/a&gt;入门阶段&lt;/h3&gt;&lt;h4 id=&quot;预备知识&quot;&gt;&lt;a href=&quot;#预备知识&quot; class=&quot;headerlink&quot; title=&quot;预备知识&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="PHP" scheme="http://jas-wang.fun/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://jas-wang.fun/tags/PHP/"/>
    
      <category term="技术栈" scheme="http://jas-wang.fun/tags/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
  </entry>
  
</feed>
